<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回溯(入门)</title>
      <link href="/2021/01/24/%E5%9B%9E%E6%BA%AF/"/>
      <url>/2021/01/24/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<p>​<strong>回溯，即递归回溯，本质上是一种枚举法。在回溯法执行时，应当：保存当前步骤，如果是一个解就输出；今天我们对回溯进行简单的入门，用讲述八皇后问题和迷宫问题。</strong></p><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p>八皇后问题（英文：Eight queens），是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。<br>问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法？高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。<br><strong>今天我们用编程解决此问题</strong>     </p><div align="center"> <img src="/2021/01/24/%E5%9B%9E%E6%BA%AF/八皇后.png" width="600px" alt="八皇后"> </div>      ### 思路分析   <h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><h4 id="编写确定规则的方法"><a href="#编写确定规则的方法" class="headerlink" title="编写确定规则的方法"></a>编写确定规则的方法</h4><p>编写规则，我们使用一维数组来实现，数组的下标i代表第几行，下标的值j代表第几列。用judge方法来判断放入的皇后是否符合要求，我们的要求是同一列中只能有1个皇后，同一斜线上只能有一个皇后；<br> 由于这里是一维数组，则不许考虑皇后在同一行的情况。    </p><p> <code>array[n]==array[i] || Math.abs( i-n )==Math.abs( array[n] -array[i] )</code>; 这行代码：如果在同一列，或者在一条斜线上的意思。    </p><pre><code>public boolean judge(int n){    for (int i = 0; i &lt; n; i++) {        if(array[n]==array[i] || Math.abs( i-n )==Math.abs( array[n] -array[i] )){            return false;        }    }    return true;}</code></pre><h4 id="编写打印所有皇后的方法"><a href="#编写打印所有皇后的方法" class="headerlink" title="编写打印所有皇后的方法"></a>编写打印所有皇后的方法</h4><p>这里直接使用for循环打印一维数组即可。比较简单，直接展示代码    </p><pre><code>private void print(){    for (int i = 0; i &lt; array.length; i++) {        System.out.print(array[i]+" ");    }    System.out.println();}</code></pre><h4 id="编写放置皇后的方法"><a href="#编写放置皇后的方法" class="headerlink" title="编写放置皇后的方法"></a>编写放置皇后的方法</h4><p>我们直接用for循环放置皇后，在放置皇后时候，先在第一行将皇后固定再第一列的位置，然后放置其他的皇后。在放置其他皇后之前，要满足上一个皇后满足规则，也就是judge方法再进行放置。以此类推，将第一行的皇后固定到在第二列。。。代码如下：      </p><pre><code> private  void  check(int n){    if(n ==  max){ //n=8时        print();        return;    }    //依次放入皇后，并判断是否冲突    for (int i = 0; i &lt; max; i++) {        //先把该皇后放在该行的第一列        array[n]=i;        if(judge( n )){ //不冲突            //接着放n+1个皇后            check( n+1 );        }        //如果冲突 ，就继续执行array[n]=i;即将第n个皇后，放置再本行后移的一个位置     }</code></pre><h3 id="回溯的体现"><a href="#回溯的体现" class="headerlink" title="回溯的体现"></a>回溯的体现</h3><p>八皇后问题是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后,如果没有位置符合要求，那么就要改变前一个皇后的位置，重新放本次皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。      </p><p><strong>接下来我们说说迷宫问题</strong>      </p><h3 id="迷宫简介"><a href="#迷宫简介" class="headerlink" title="迷宫简介"></a>迷宫简介</h3><div align="center"> <img src="/2021/01/24/%E5%9B%9E%E6%BA%AF/migong.png" width="600px" alt="迷宫"> </div>         <p>这是我们的迷宫（8*7），红色地区为墙体，我们只能在白色区域内移动，从左上方（[0][0]）的这个位置开始移动，移动到箭头所指的位置（[6][5]）上即可。这里我们通过二维数组来实现迷宫地图，分别代表迷宫的行和列。        </p><h3 id="迷宫的走法"><a href="#迷宫的走法" class="headerlink" title="迷宫的走法"></a>迷宫的走法</h3><p>我们走这个迷宫的思路是下，右，上，左。即先忘下走，如果下边不能走通，就往右走，进而右边不能走通，在考虑往上走；上边也不能走通时，就往左走。<br>这就是本次迷宫问题的走法，这只是其中一种。小伙伴们也可以采取右，下，上，左的思路。走法有很多种的。     </p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="编写迷宫地图"><a href="#编写迷宫地图" class="headerlink" title="编写迷宫地图"></a>编写迷宫地图</h4><p>使用二维数组来代替迷宫map[8][7];墙体部分的数据设置为1；代码如下：   </p><pre><code>    int[][] map = new int[8][7];    //使用1来表示墙，先把上下值为1    for(int i =0;i&lt;7;i++){        map[0][i]=1;        map[7][i]=1;    }    //把左右的墙体置为1    for(int i =0;i&lt;8;i++){        map[i][0]=1;        map[i][6]=1;    }    //设置中间部分的墙体    map[3][1]=1;    map[3][2]=1;    //输出地图    System.out.println("地图的情况");    for (int i = 0; i &lt; 8; i++) {        for (int j = 0; j &lt; 7; j++) {            System.out.print(map[i][j]+" ");        }        System.out.println();    }   </code></pre><p> 地图代码运行的结果：<br> </p><div align="center"> <img src="/2021/01/24/%E5%9B%9E%E6%BA%AF/地图1.png" width="600px"> </div><p></p><h4 id="编写迷宫的走法"><a href="#编写迷宫的走法" class="headerlink" title="编写迷宫的走法"></a>编写迷宫的走法</h4><p> 编写setWay方法，如果可以走返回true，否则false；我们将走过的痕迹标为2，死路标为3. 如果走到[6][5]的位置，则成功。每次行走之前要将本次位置标为2，留下行走痕迹，表示走过；如果map[i][j]等于0，则表示此路未走过，才可以使用我们之前的策略(下右上左)。代码实现：   </p><pre><code>public static boolean setWay(int[][] map,int i,int j){    if(map[6][5]==2){ //通路已经找到        return true;    }else{        if(map[i][j]==0){ //如果该点没走过            //按照策略走            map[i][j]=2;//假定该点可以走通            if(setWay(map,i+1,j )){//向下走                return true;            }else if(setWay( map,i,j+1 )){ //向右走                return true;            }else if(setWay( map,i-1,j )){//向上走                return true;            }else if(setWay( map,i,j-1 )){ //向左走                return true;            }else{                map[i][j]=3;//死路                return false;            }        }else { //说明是1，2，3            return false;        }    }}</code></pre><p>代码实现的结果：        </p><div align="center"> <img src="/2021/01/24/%E5%9B%9E%E6%BA%AF/地图2.png" width="600px"> </div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫问题</title>
      <link href="/2020/10/22/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/22/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2><p><strong>Josepfu问题：</strong>    </p><h3 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h3><p><strong>约瑟夫问题，又称约瑟夫环。设置编号为1，2，…n的n个人围坐成一圈，约定编号为k(k要小于总体人数)的人从1开始报数，数到m的那个人出列，他的下一位继续从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列</strong>       </p><div align="center"> <img src="/2020/10/22/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/1.png" width="600px" alt="约瑟夫环"> </div>  <p><strong>其实我们无非就是一个环，报道那个数字，就删除那个数字。思路就是这样。我们可以用数组或者环状链表来实现，今天我们先来介绍用环状链表实现约瑟夫问题</strong>    </p><h3 id="环状链表"><a href="#环状链表" class="headerlink" title="环状链表"></a>环状链表</h3><h4 id="创建环形链表"><a href="#创建环形链表" class="headerlink" title="创建环形链表"></a>创建环形链表</h4><p><strong>思路</strong>     </p><div align="center"> <img src="/2020/10/22/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/2.png" width="600px" alt="创建环形链表"> </div>  <p>我们先创建第一个节点，让first指向该节点，并形成环状，我们要设置一个辅助变量curboy，当我们创建第一个节点的时候，让curboy的下一个节点指向first，也就是自己指向自己，即<code>curboy.setNext(first)</code>,后面我们添加一个节点，就把该节点加入到已有的环形链表中即可。当添加一个节点的时候，让curboy指向这个新boy，再让这个新boy的下一个节点指向first，这样就成为了一个闭环</p><pre><code> //创建一个first节点，当前没有编号private Boy first = null;//添加小孩节点，构建成一个环形的链表public void addBoy(int nums){    if(nums&lt;1){        System.out.println("nums的值不正确");        return;    }    Boy curBoy =null;//辅助指针，帮助构建环形链表    //使用for循环来构建环形链表    for (int i = 1; i &lt;= nums; i++) {        //根据编号，创建小孩节点        Boy boy = new Boy(i);        //如果是第一个小孩        if(i == 1){            first =boy;            first.setNext( first );//构成环            curBoy = first;//让curBoy指向第一个小孩        } else {            curBoy.setNext( boy );            boy.setNext( first );            curBoy =boy;         }    }}  </code></pre><h4 id="遍历环形链表"><a href="#遍历环形链表" class="headerlink" title="遍历环形链表"></a>遍历环形链表</h4><p><strong>思路</strong>    </p><div align="center"> <img src="/2020/10/22/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/3.png" width="600px" alt="创建环形链表"> </div>    <p>先创建一个辅助变量curboy，指向first节点，再依次遍历，让curboy不断地后移，并且不断打印输出。当curboy的下一个节点等于first的时候，我们就完成了遍历<br><strong>代码</strong>   </p><pre><code>//遍历当前的环形链表public void showBoy(){    //判断链表是否为空    if(first == null){        System.out.println("没有任何小孩。。");        return;    }    //因为first不能动，因此我们仍然使用一个辅助指针完成遍历    Boy curBoy =first;    while (true){        System.out.printf("小孩的编号 %d \n",curBoy.getNo());        if(curBoy.getNext() == first){ //说明已经遍历完成            break;        }        curBoy = curBoy.getNext();//curBoy后移    }} </code></pre><h3 id="Josepfu问题"><a href="#Josepfu问题" class="headerlink" title="Josepfu问题"></a>Josepfu问题</h3><p><strong>学习了如何创建，遍历环形链表之后我们来解决约瑟夫问题</strong><br><strong>我们先用简单的一个约瑟夫环，手动数数，方便之后的确认数据</strong>   </p><hr><p><strong>这是一个简单的约瑟夫环，我们让起点startNo为1，一次数两个人countnum为2，总共有5个人num=5。我们一次数，数完后我们发现依次出圈的数字为2-&gt;4-&gt;1-&gt;5-&gt;3。ok，我们现在讲一讲用代码实现约瑟夫环的思路</strong>    </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><div align="center"> <img src="/2020/10/22/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/4.png" width="600px" alt="创建环形链表"> </div>   <p><strong>创建两个变量，一个是first，指向第一个节点。另一个是helper，指向最后一个节点。首先，我们先将first和helper移动开始数的位置，这次是从1开始数的，所以不用移动，如果下次是从startNo=3开始数的话，我们就要移动first和helper，分别将helper和first向后移动startNo-1次。移动好位置后，可以开始了，num=2，从第一个孩子报数，第二个孩子截至，所以first和helper向后移动num-1次。移动好后，first指向的boy就是我们要移除的boy。要删除该boy，可以将first向后移动一个单位，再将helper的next直接指向first。这样就没有任何指针指向刚才的那个boy了，即已经被删除了，系统也会自动回收这个垃圾。</strong><br><strong>另外强调，我们是如何将helper指向最后一个节点的？将helper向后移动，当helper的下一个节点是first的时候，即<code>helper.getnext()==first</code>,就break。</strong>   </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>public  void count(int startNo,int coutNum,int nums){        if(startNo&lt;1 || startNo&gt;nums ||first ==null){            System.out.println("输入有误，请重新输入");            return;        }        Boy helper = first;        while (true){            if(helper.getNext()==first){                break;            }            helper = helper.getNext();    }    for (int i = 0; i &lt; startNo-1; i++) {        helper=helper.getNext();        first=first.getNext();    }    while(helper==first){    for (int i = 0; i &lt; nums-1; i++) {        helper=helper.getNext();        first=first.getNext();    }    System.out.printf("小孩%d出圈\n",first.getNo());    first =first.getNext();    helper.setNext( first );    }    System.out.println("最后留在圈中的小孩编号为"+first.getNo());}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="/2020/10/22/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/10/22/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><strong>上一篇我们介绍了单向链表，我们能发现，单向链表中有许多不足的地方，比如节点不能自我删除，链表查找的方向只能是从前往后这一个方向。今天我们来介绍的双向链表，可前可后的查找节点，原理也很简单，在之前的单向链表的节点中新增加了一个元素(pre),这个元素作用指向自己的前一个节点</strong>     </p><h3 id="双向链表的CRUD"><a href="#双向链表的CRUD" class="headerlink" title="双向链表的CRUD"></a>双向链表的CRUD</h3><div align="center"> <img src="/2020/10/22/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/1.png" width="600px" alt="双向链表"> </div>           <p><strong>这就是一个简单的双向链表，接下来我们一起学习对双向链表的增删改查</strong><br><strong>首先，双向链表的遍历与节点的修改和单项链表的方法是一样的，这里就不赘述了。小伙伴们可以翻一翻上篇博客，在看的过程中建议拿笔画一画更方便理解</strong>     </p><h3 id="节点的添加"><a href="#节点的添加" class="headerlink" title="节点的添加"></a>节点的添加</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><div align="center"> <img src="/2020/10/22/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/2.png" width="600px" alt="链表节点的添加"> </div>     <p><strong>首先，我们需要找到双向链表的最后一个节点，因为first节点不能动，我们事先要创建一个辅助变量temp来帮我们查找，这里可以采用while循环，当<code>temp.next=null</code>的时候，即是找到了最后一个节点。之后我们再让temp的下一个节点指向新节点即可，同时再让新节点的pre(前一个节点)指向temp，这样就完成了新节点的添加</strong>    </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>//添加节点public void add(HeroNode heroNode){    HeroNode temp = head;    while(true){        if(temp.next ==null) {            temp.next = heroNode;            heroNode.pre = temp;            break;        }        temp=temp.next;    }}</code></pre><h3 id="节点的删除"><a href="#节点的删除" class="headerlink" title="节点的删除"></a>节点的删除</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><div align="center"> <img src="/2020/10/22/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/3.png" width="600px" alt="链表节点的删除"> </div> <p><strong>因为是双向链表，所以我们可以实现自我删除某个节点，我们可以直接找到该节点，让该节点的的前一个节点的next指向下一个的下一个，让该节点之后的节点的pre指向前一个的前一个。这样就没有任何指针指向temp这个节点了，也就删除了temp这个节点，系统会回收这个垃圾</strong><br><strong>注意：代码中我们引入了一个变量flag，这个变量使用来判断是否满足删除的条件，如果找不到被删除的元素，flag会为false，找到要被删除的元素时候flag会变成true。当然，这里你也可以不引入flag变量来判断。</strong> </p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code> //删除一个节点public void del(int no){    HeroNode temp =head;    boolean flag =false;    while(true){        temp=temp.next;        if(temp.no == no){            flag=true;            break;        }        if(temp.next==null){            break;//如果遍历到最后还没找到该元素，就直接break        }    }    if(flag){        if(temp.next!=null){            temp.next.pre=temp.pre;        }        temp.pre.next =temp.next;    }    else{        System.out.println("未找到要删除的元素");    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的CRUD</title>
      <link href="/2020/10/19/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/10/19/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p> <strong>今天我们来学习单链表，首先链表是一种数据结构，里面的每个元素都包含下一个元素的位置信息，我们可以用它来存储数据。和数组很像，但也有区别，下面我们会讲到的。如下图是一个简单的单链表</strong><br> </p><div align="center"> <img src="/2020/10/19/%E5%8D%95%E9%93%BE%E8%A1%A8/1.png" width="600px" alt="单链表"> </div>           <p></p><p> <strong>链表都是以节点(node)的方式来存储的，我们看上图可以看到一个节点有两部分组成，一个是data域，一个是next域(由于java中没有指针的这一概念，我们将其标注为next域，next域用于指向下一个节点的位置。）所以我们也可以发下链表的各个节点不是连续存储的，而是采用的next域指向下一个节点的位置</strong><br> <strong>知道了链表的概念之后，我们就知道了数组和链表的区别，笔者也突然想起了一个经典的面试题</strong>    </p><blockquote><p>ArrayList和LinkedList有什么区别？<br>首先ArryList是实现了基于动态数组的数据结构，LinkedList是基于链表的结构。两者都实现了基于List接口的容器类，用于存储一系列的元素，他们都可以对元素进行CRUD<br>他们在集合的末尾增删元素所用时间是一致的，但是在列表的中间的部分增删元素中所用的时间是不一样的。<br>对于对元素查找的时候，ArrayList的速度优于LinkedList的，因为LinkedList需要移动指针。比如在1，2，3，4，5。这5个元素中，数组找到5会直接找到该元素，而链表则需要通过指针的指向一个一个的查找。<br>对于增删操作，linkedlist占优势，因为ArrayList需要移动数据。linkedlist在增删一个数据的时候，只需更改指针的指向(指向新增的元素或者指向删除元素的下一个元素的位置)。而ArrayList在增删一个元素的时候，都会影响到后面元素的前进或者后退。</p></blockquote><p><strong>当然以上只是一些简单的区别。回到我们今天所学的链表中，在链表的逻辑结构中会有一个头节点。头节点不会存放具体的数据，即data域没内容，但next域有内容，指向第一个节点。作用就是表示单链表的表头。还有尾节点，尾节点不会有next域了。而其他的节点都会有data域和next域。</strong>      </p><div align="center"> <img src="/2020/10/19/%E5%8D%95%E9%93%BE%E8%A1%A8/2.png" width="600px" alt="头节点和尾节点"> </div>      <h3 id="链表的创建"><a href="#链表的创建" class="headerlink" title="链表的创建"></a>链表的创建</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>我们先创建一个类，这个类即是一个节点(Node)，要包括一个int数值，用来作为索引，还有节点的数据(name，nickname)，还有next域。我们如下定义一个HeroNode,把数据域和next域写入，并用tostring方法重写</strong>  </p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>//定义一个HeroNode，每一个node都是一个节点class HeroNode{    public int no;    public String name;    public String nickname;    public HeroNode next;//下一个节点    //构造器    public HeroNode(int no,String name,String nickname){        this.no =no;        this.name=name;        this.nickname=nickname;    }    @Override    public String toString() {        return "HeroNode{" +                "no=" + no +                ", name='" + name + '\'' +                ", nickname='" + nickname + '\'' +                '}';    }}</code></pre><h3 id="链表节点的添加"><a href="#链表节点的添加" class="headerlink" title="链表节点的添加"></a>链表节点的添加</h3><h4 id="在末尾添加节点"><a href="#在末尾添加节点" class="headerlink" title="在末尾添加节点"></a>在末尾添加节点</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p><strong>首先上面的链表我们还需要添加一个头节点（不存放数据）。之后我们来创建一个添加元素的方法(add();)),我们要知道头节点不能动，所以要定义一个节点先充当头节点，然后用该节点后移动来指向后面的每一个节点。通过该节点找到最后一个节点，当然只需要判断其节点的next是否为null，就可知到是否为尾节点。找到尾节点后，再将temp.next的位置让给新节点，这样我们就完成了在未尾插入新元素</strong>       </p><div align="center"> <img src="/2020/10/19/%E5%8D%95%E9%93%BE%E8%A1%A8/3.png" width="600px" alt="末尾添加节点的前后对比"> </div>  <h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code>class  SingleLinkedList{    //定义一个头节点，不存放任何数据    private HeroNode head = new HeroNode( 0,"","" );    //创建一个方法用来添加新节点    public void add(HeroNode heroNode){        HeroNode temp = head;        //找到最后一个节点        while(true) {            if (temp.next == null) {                break;            }            temp=temp.next;        }        temp.next = heroNode;    }</code></pre><h4 id="按照顺序添加节点"><a href="#按照顺序添加节点" class="headerlink" title="按照顺序添加节点"></a>按照顺序添加节点</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p><strong>在中间和末尾添加元素的思路是不一样的，在中间插入时候，temp需要变成找到插入点的前一个元素，并且该位置元素的next要大于新节点的no，才能说明此位置有空缺，可插入新元素。之后要进行<code>heroNode.next =temp.next;temp.next=heroNode;</code>的操作。这两句代码是将新节点插入进去，并且新节点之前的节点指向新节点，新节点指向后面的节点。可能会不好理解，建议用笔画一画</strong><br> </p><div align="center"> <img src="/2020/10/19/%E5%8D%95%E9%93%BE%E8%A1%A8/4.png" width="600px" alt="按顺序插入节点"> </div>   <p></p><pre><code>public void  addbyorder(HeroNode heroNode){        HeroNode temp = head;        boolean flag = false;        while (true) {            if (temp.next==null){                break;            }            else if(temp.next.no&gt;heroNode.no){                break;            }else if(temp.next.no==heroNode.no){                flag = true;            }            temp=temp.next;        }        if(flag){            System.out.println("此位置已经有了节点，不能再添加");        }else{            heroNode.next =temp.next;            temp.next=heroNode;        }    }  </code></pre><h3 id="链表节点的遍历"><a href="#链表节点的遍历" class="headerlink" title="链表节点的遍历"></a>链表节点的遍历</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p><strong>先要明确，遍历之前我们保证链表不能为空，也就是head.next不能为null。然后定义一个辅助变量temp，temp先指向头节点的位置。遍历的时候我们也要保证temp.next不能为null，也就是下一个节点不能为空，为空说明我们已经遍历完了。然后每输出一个节点的信息，并将temp后移动一个位置</strong>      </p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>public void show(){    HeroNode temp = head;    //先判断链表是否为空    if(head.next == null){        System.out.println("链表为空，不能遍历");        return;    }    //遍历    //先判断链表是否还有下一个节点，有的话遍历，知道没有    while(temp.next != null){        temp = temp.next;        System.out.println(temp);    }}  </code></pre><h3 id="链表节点的删除"><a href="#链表节点的删除" class="headerlink" title="链表节点的删除"></a>链表节点的删除</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>首先删除元素我们需要知道元素的位置，所以在定义方法的时候需要传进来一个int的值。我们需要找到要被删除元素的前一个元素，直接讲前一个元素的next指向下下一个元素即可，即temp.next=temp.next.next。我们要注意被删除的元素将不会有其他引用指向，会被垃圾回收机制回收</strong>     </p><div align="center"> <img src="/2020/10/19/%E5%8D%95%E9%93%BE%E8%A1%A8/5.png" width="600px" alt="删除节点"> </div> <h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>  public void del(int num){        HeroNode temp = head;        boolean flag = false;        while(true){            if(temp.next == null){            break;            }            if(temp.next.no==num){                flag=true;                break;            }            temp = temp.next;        }        if(flag){            temp.next=temp.next.next;        }    else{            System.out.println("要删除的节点不存在");        }}</code></pre><p><strong>注意：这里新增的flag只是作为判断的标志，找到该节点会变为true执行相关的操作，如果没有找到要删除的节点则一直为false</strong>   </p><h3 id="链表节点的修改"><a href="#链表节点的修改" class="headerlink" title="链表节点的修改"></a>链表节点的修改</h3><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><strong>在修改节点的时候，注意我们不是找到该节点来修改，而是传进来一个与旧节点no值一样的新节点来替换旧节点，从而做到节点修改的效果。我们定义一个辅助变量temp来查找，将temp一直往后移动，寻找要替换的节点，直到temp.no=heronode.no的时候，我们就可以替换。</strong>    </p><div align="center"> <img src="/2020/10/19/%E5%8D%95%E9%93%BE%E8%A1%A8/6.png" width="600px" alt="修改节点"> </div> <h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>    public void update(HeroNode newheroNode){        boolean flag =false;        HeroNode temp= head;        //判断是否为空        if(temp.next == null){            System.out.println("链表为空");            return;        }        while(true){        if(temp==null){//已经遍历完表了            break;        }        else if(temp.no==newheroNode.no){            flag = true;            break;        }        temp = temp.next;        }        //根据flag判断是否有无该节点        if(flag){            temp.name=newheroNode.name;            temp.nickname=newheroNode.nickname;        }else{            System.out.println("没找到序号");        }    }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2020/10/13/%E9%98%9F%E5%88%97/"/>
      <url>/2020/10/13/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>今天我们来学习队列，队列在我们生活中很常见，比如超市收费排队。我们可以用于数组来演示出来下图的</strong> </p><div align="center"> <img src="/2020/10/13/%E9%98%9F%E5%88%97/1.png" width="600px" alt="超市排队"> </div>    <h3 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a><strong>队列的概念</strong></h3><p><strong>队列可以有循环队列，和非循环队列。 队列是一个有序列表，可以用数组或者是链表来实现，遵循先入先出(FIFO)的原则。今天的内容都是用数组来演示的。</strong><br><strong>接下来我们用数组模拟队列</strong>       </p><h2 id="非循环队列"><a href="#非循环队列" class="headerlink" title="非循环队列"></a>非循环队列</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><div align="center"> <img src="/2020/10/13/%E9%98%9F%E5%88%97/2.png" width="600px" alt="非循环队列"> </div>       <p><strong>上图是一个非循环队列。队列的输出，输入分别从前后端来处理，需要三个变量front，rear和maxsize(数组的最大容纳量)。front随着数据的输出而改变，rear随着数据的输入而改变。开始的时候front和rear都等于-1，front指向队列头的前一个位置，rear指向等列尾的最后一个数据</strong>     </p><div align="center"> <img src="/2020/10/13/%E9%98%9F%E5%88%97/3.png" width="600px" alt="非循环队列"> </div>    <p><strong>这是添加元素后的队列，当添加元素的时候，rear先向后移动一个单位，将新元素放在<code>arr[rear]</code>上。取出元素的时候，先将front向后移动一个单位，取出<code>arr[front]</code></strong> </p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1⃣️ <strong>创建队列的构造器</strong><br><strong>front=-1:指向队列的头部，分析出front是指向队列头的前一个位置</strong><br><strong>rear =-1：指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</strong><br>2⃣️ <strong>判断队列是否为满</strong><br>    <strong>rear==maxsize -1</strong>   </p><p>3⃣️ <strong>判断队列是否为空</strong><br> <strong>rear==front</strong><br>4⃣️ <strong>添加数据到队列</strong><br><strong>先判断队列是否满，，不满的话，rear指向的是最后一个元素，需要将rear后移一个位置，添加新元素</strong><br>5⃣️ <strong>获取队列的数据，出队列</strong><br><strong>先判断队列是否为空，空的话需要return一个异常，不能</strong><code>return -1;</code> <strong>因为会误以为出队列的值为-1</strong><br><strong>队列有值时，要将front后移，传出</strong><code>arr[front]</code><br>6⃣️ <strong>显示队列所有数据</strong><br><strong>仍然需要判断队列是否为空，空则无法遍历。队列有值时，即可遍历数组</strong><br>7⃣️ <strong>显示队列的头数据</strong><br><strong>先判断队列是否为空，队列有值时，可以</strong><code>return arr[front + 1];</code>   </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>//创建队列构造器 class Arrayqueue{    int[] arr;     private int front;    private int rear;    private  int maxsize;    public Arrayqueue( int arrMaxsize){    maxsize = arrMaxsize;    arr =new int[maxsize];    rear =front=-1;}//判断队列是否满public boolean isFull(){    return  rear==maxsize;}//判断队列是否为空 public boolean isNull(){    return  rear==front;}//添加元素public void addQueue(int n){    if(isFull()){        System.out.println("队列已满");    }    else {        rear++;        arr[rear]=n;    }}//获取队列的头数据public int getwQueue(){    if(isNull()){        throw new RuntimeException( "队列为空，无法获取" );    }    else{        front++;        return arr[front];    }}//显示队列所有的数据public void showQueue() {    if (isNull()) {        System.out.println( "队列为空，无法遍历" );    } else {        for (int i = 0; i &lt; arr.length; i++) {            System.out.printf( "arr[%d]=%d\n", i, arr[i] );        }    }}//查看头数据是谁public int headQueue(){    if(isNull()){        throw new RuntimeException( "队列为空，无法获取");    }    else{        return arr[front + 1];    }}</code></pre><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p><strong>这个队列是非循环队列，当数组的0和1号位置的元素删除后就不能在此位置添加新元素了。所以我们需要用循环队列来优化</strong>   </p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><div align="center"> <img src="/2020/10/13/%E9%98%9F%E5%88%97/4.png" width="600px" alt="‘循环队列’"> </div>      <h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><div align="center"> <img src="/2020/10/13/%E9%98%9F%E5%88%97/6.png" width="900px"> </div>     <p><strong>这是添加元素的过程，左图的rear总要指向最后一个元素的后一个位置，当添加新元素时候，可以设置一个临时变量value(value=rear),在</strong><code>arr[value]</code><strong>赋值。只会要将rear后移一个位置。删除元素的时候，只需返回<code>arr[front]</code>即可，再将front后移一个位置。</strong><br><strong>注意，循环队列的最后要空出一个位置，作为约定，也就是上图右边rear所指向的位置。如果不空出该位置的话，队列满时，会造成<code>front=rear</code>与队列为空的判断互相矛盾。</strong>      </p><p>1⃣️ front变量的含义：front就指向队列的第一个元素，也就是说**<code>arr[front]</code>就是队列的第一个元素，front的初始值为0<br>2⃣️ rear变量的含义：因为希望空出一个空间作为约定，rear指向队列的最后一个元素的最后一个位置。rear的初始值为0        </p><div align="center"> <img src="/2020/10/13/%E9%98%9F%E5%88%97/5.png" width="600px"> </div>         <p><strong>3⃣️ 当队列满的时候，条件是(rear+1)%maxsize =front</strong><br><strong>4⃣️ 当队列为空的时候，rear==front</strong><br><strong>5⃣️ 队列中有效元素的个数为(rear+maxsize-front)%maxsize</strong>   </p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><pre><code>class CircleArray{    private int maxsize;    private int front;    private int rear;    private int[] arr;//创建构造器 public CircleArray(int size){     maxsize =size;     arr =new int[size]; } public boolean isFull(){     return (rear+1)%maxsize == front; } public boolean isNull(){     return  rear == front; } //添加数据到队列public void addArr(int sum){    if(isFull()){        System.out.println("队列已满，不能再添加了");    }    arr[rear]=sum;    rear = (rear+1)%maxsize; } //获取队列的数据，出队列public int getArr(){     if(isNull()){         throw new RuntimeException( "队列为空，无元素取出" );     }     int value = arr[front];     front = (front +1)% maxsize;     return arr[value]; } //显示队列的所有元素public void showArr(){     if(isNull()){         throw new RuntimeException( "队列为空，无元素遍历" );     }     for(int i =front; i &lt; (front+(rear+maxsize-front)%maxsize);i++){         System.out.println(arr[i%maxsize]);     } } public int headArr(){     if(isNull()){        throw  new RuntimeException( "队列为空，无元素" );     }     return arr[front]; }</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="/2020/10/11/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2020/10/11/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>数据结构包括线性结构和非线性结构</strong>     </p><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p><strong>①线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</strong><br><strong>②线性结构有两种不同的存储结构</strong>     </p><blockquote><p>顺序存储：顺序表，顺序表中的存储元素是连续的（地址连续）<br>链式存储：链表，链表中的存储元素不一定是连续的（元素节点中会存放数据元素以及相邻元素的地址信息）   </p></blockquote><p><strong>线性结构常见的有：数组，队列，链表和栈</strong>     </p><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p><strong>二维数组，多维数，广义表，树结构，图结构</strong>   </p><p><strong>今天我们先来学习稀疏数组</strong>   </p><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p><strong>应用场景</strong>       </p><p><img src="/2020/10/11/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/4.png" alt="棋盘"><br><strong>这是一个棋盘，底层的数据可以用数组表示，其中棋盘没有棋子的时候可以表示为0，黑棋子可以表示为1，蓝色棋子表示为2。所以，当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来存放该数组</strong></p><p><strong>我们来观察一个数组</strong><br><img src="/2020/10/11/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/1.png"><br><strong>这是一个11x11的数组，也就是说要将这个数组表示出来需要11x11个数据。这个数组可以用二维数组表示出来，如下</strong>    </p><pre><code>int[][]  arr = new int[11][11];</code></pre><p><strong>在这个二维数组中要存储11x11个数据才能表示出上图的内容。今天我们要简化数组占用的内存大小，就要用到稀疏数组，用稀疏数组表示上图，如下</strong>    </p><p><img src="/2020/10/11/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/2.png">      </p><p><strong>红色线框即是一个稀疏数组，共有9个值。</strong>      </p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p><strong>下面我来解释解释这9个值的含义</strong><br><strong>首先是第一行</strong><br><img src="/2020/10/11/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/3.png"><br><strong>稀疏数组的第一行记录的就是二维数组的行列的个数，以及非零值</strong><br>前两个数据代表原来表格有11行，11列，最后一个代表者有2个非0值<br><strong>第二行</strong><br>这三个数据分别代表在原来表格的第一行，第二列值为1。<strong>第三行以此类推</strong><br><strong>稀疏数组的处理方式</strong><br>1⃣️ 记录数组一共有几行几列，有多少个不同的值<br>2⃣️ 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 </p><h4 id="二维数组转成稀疏数组"><a href="#二维数组转成稀疏数组" class="headerlink" title="二维数组转成稀疏数组"></a>二维数组转成稀疏数组</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>1⃣️ <strong>先遍历原始的二维数组，得到有效数据的个数sum</strong><br>2⃣️ <strong>根据sum就可以创建出稀疏数组</strong><br><code>int[sum+1][3]</code><br>一个有效值就会占用一行，得到有效值的个数sum后要再加上稀疏数组第一行的信息就是稀疏数组的行数<br>3⃣️ <strong>将二维数组的有效数据存放到稀疏数组中</strong>判断原始二维数组是否有非零，如果非零，记录出数据在二维数组的位置和值       </p><h5 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h5><pre><code>//将二维数组转换成稀疏数组    int sum = 0;    for (int i = 0; i &lt; 11; i++) {        for (int j = 0; j &lt; 11; j++) {            if (chessarr1[i][j] != 0) {                sum++;            }        }    }    int chessarr2[][] = new int[sum + 1][3];    chessarr2[0][0] = 11;    chessarr2[0][1] = 11;    chessarr2[0][2] = sum;    int count = 0;    for (int i = 0; i &lt; 11; i++) {        for (int j = 0; j &lt; 11; j++) {            if (chessarr1[i][j] != 0) {                count++;                chessarr2[count][0] = i;                chessarr2[count][1] = j;                chessarr2[count][2] = chessarr1[i][j];            }        }    }    for (int i = 0; i &lt; chessarr2.length; i++) {        for (int j = 0; j &lt; chessarr2[i].length; j++) {        }        System.out.printf( "%d\t%d\t%d\t", chessarr2[i][0], chessarr2[i][1], chessarr2[i][2] );        System.out.println();    }}</code></pre><h4 id="稀疏数组转成二维数组"><a href="#稀疏数组转成二维数组" class="headerlink" title="稀疏数组转成二维数组"></a>稀疏数组转成二维数组</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>1⃣️ <strong>先读取稀疏数组的第一行，根据第一行的数据创建原始的二维数组</strong>稀疏数组第一行记录的内容即是二维数组的行列，和非零值<br>2⃣️ <strong>在读取稀疏数组后几行的数据，并赋给原始的二维数组即可</strong>   </p><h5 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h5><pre><code>//将稀疏数组转成二维数组    //获取二维数组的长度，并给所有元素赋予默认值0    int[][] chessarr3 = new int[ chessarr2[0][0]][chessarr2[0][1]];    //给有数据的值      for (int i = 1; i &lt; chessarr2.length; i++) {           chessarr3[chessarr2[i][0]][chessarr2[i][1]] = chessarr2[i][2];        }       for (int[] row : chessarr3) {        for (int data : row) {            System.out.printf( "%d\t", data );        }        System.out.println();</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/2020/10/07/Tomcat/"/>
      <url>/2020/10/07/Tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="网络通信三要素"><a href="#网络通信三要素" class="headerlink" title="网络通信三要素"></a>网络通信三要素</h2><p><strong>1.IP：电子设备(计算机)在网络中的唯一标识</strong><br><strong>2.端口：应用程序在计算机中的唯一标识</strong><br><strong>3.传输协议：规定了数据传输的规则</strong>   </p><blockquote><p><strong>基础协议：</strong><br><strong>1.TCP：安全协议，三次握手，速度稍慢</strong><br><strong>2.UCP：不安全协议，速度慢</strong>   </p></blockquote><h2 id="Web服务器软件"><a href="#Web服务器软件" class="headerlink" title="Web服务器软件"></a>Web服务器软件</h2><p><strong>服务器：安装了服务器软件的计算机</strong><br><strong>服务器软件：接受用户的请求，处理请求，做出响应</strong><br><strong>Web服务器软件：</strong><br><strong>在Web服务器软件中，可部署Web项目让用户通过游览器访问</strong>     </p><h2 id="常见的Java相关的Web服务器软件"><a href="#常见的Java相关的Web服务器软件" class="headerlink" title="常见的Java相关的Web服务器软件"></a>常见的Java相关的Web服务器软件</h2><p><strong>1.Weblogic</strong>Oracle公司，大型JavaEE服务器，支持所有JavaEE规范，收费的。    </p><blockquote><p>JavaEE：Java语言在企业级开发使用的技术规范的总和，一共规范了13项大的规范   </p></blockquote><p><strong>2.Websphere</strong><br><strong>3.JBoss</strong><br><strong>4.Tomcat：</strong>Apache基金组织，中小型的JavaEE服务器，仅支持少量的JavaEE规范，开源，免费的。       </p><h2 id="Tomcat目录结构"><a href="#Tomcat目录结构" class="headerlink" title="Tomcat目录结构"></a>Tomcat目录结构</h2><p><img src="/2020/10/07/Tomcat/1.png"><br><strong>bin：可执行文件</strong><br><strong>conf：可配文件</strong><br><strong>lib：依赖jar包</strong><br><strong>logs：日志文件</strong><br><strong>temp：临时文件</strong><br><strong>Webapps：存放web项目</strong>    </p><h2 id="Tomcat的部署"><a href="#Tomcat的部署" class="headerlink" title="Tomcat的部署"></a>Tomcat的部署</h2><p><em>三种方法，常用第三种</em>    </p><h3 id="直接将项目放到Webapps目录下即可"><a href="#直接将项目放到Webapps目录下即可" class="headerlink" title="直接将项目放到Webapps目录下即可"></a>直接将项目放到Webapps目录下即可</h3><p><strong>/hello：项目的访问路径-&gt;虚拟目录</strong><br><strong>简化部署：将项目打成一个war包，再将war包放置到Webapps下，war包会自动解压缩</strong>     </p><h3 id="配置conf-server-xml文件"><a href="#配置conf-server-xml文件" class="headerlink" title="配置conf/server.xml文件"></a>配置conf/server.xml文件</h3><p><strong>在<code>&lt;host&gt;</code>标签体中配置</strong>    </p><pre><code>    &lt;Context dacBase="D:\hello" path="/haha" /&gt;   </code></pre><p><strong>dacBase:项目存放的路径</strong><br><strong>path：虚拟目录</strong>    </p><h3 id="创建任意名称的xml文件"><a href="#创建任意名称的xml文件" class="headerlink" title="创建任意名称的xml文件"></a>创建任意名称的xml文件</h3><p><strong>在conf/Catalina/localhost创建任意名称的xml文件，在文件中编写</strong>    </p><pre><code>&lt;Context docBase="D:/hello" /&gt;   </code></pre><p><strong>虚拟目录：xml文件的名称</strong>    </p><h3 id="Tomcat的使用"><a href="#Tomcat的使用" class="headerlink" title="Tomcat的使用"></a>Tomcat的使用</h3><p><strong>打开：</strong><br>在bin文件中执行startup.bat文件<br><strong>为了验证是否启动成功，可以在游览器中输入<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></strong>    </p><p><img src="/2020/10/07/Tomcat/2.png">   </p><p><strong>关闭：</strong><br>有三种方法。<br>第一种：Ctrl+C键 关闭Tomcat服务器<br>第二种：点击Tomcat窗口的右上角关闭按钮 （暴力停止服务器）<br>第三种：找到tomcat目录/bin/shutdown.bat文件，双击执行关闭  Tomcat。      </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap框架</title>
      <link href="/2020/09/27/Bootstrap/"/>
      <url>/2020/09/27/Bootstrap/</url>
      
        <content type="html"><![CDATA[<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>一个前端开发的框架，Bootstrap，来自Twitter，是目前很受欢迎的前端框架，是基于HTML，CSS，JavaScript</strong>  </p><blockquote><p>框架：一个半成品软件，开发人员可以在框架基础上在进行开发，简化编码      </p></blockquote><p><strong>好处：</strong><br>1.定义了很多的CSS样式和JS插件，开发人员可直接使用<br>2.<strong>响应式布局</strong>：同一套页面可兼容不同分辨率的设备    </p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>1.下载Bootstrap<br>2.在项目中将html，css，js这三个文件夹导入<br>3.创建html页面，引入必要的资源文件<br><strong>在Bootstrap中书写Hello World</strong></p><pre><code>    &lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;&lt;title&gt;Bootstrap HelloWorld&lt;/title&gt;&lt;!-- Bootstrap --&gt;&lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt;&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;&lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt;&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;&lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p><strong>实现：依赖于栅格系统，将一行平均分成12个格子，可以指定元素占几个格子</strong><br>步骤：  </p><h3 id="1-定义容器"><a href="#1-定义容器" class="headerlink" title="1.定义容器"></a>1.定义容器</h3><p><strong>container：两边留白</strong><br><strong>container-fluid：每一种设备都是100%宽度</strong>    </p><h3 id="2-定义行"><a href="#2-定义行" class="headerlink" title="2.定义行"></a>2.定义行</h3><p><strong>相当于之前的tr，样式：row</strong>   </p><h3 id="3-定义元素"><a href="#3-定义元素" class="headerlink" title="3.定义元素"></a>3.定义元素</h3><p><strong>指定元素在不同的设备上，所占的格子数目。</strong><br>样式：col-设备代号-格子数目<br><strong>设备代号</strong><br>1.xs ：超小屏幕  手机(&lt;768PX&gt;): col-xs-12<br>2.sm ：小屏幕   平板(&gt;768PX)<br>3.md ：中等屏幕 桌面显示器(&gt;992PX)<br>4.lg ：大屏幕 大桌面显示器(&gt;1200PX)     </p><pre><code>1.定义容器&lt;div class="container"&gt;    2.定义行    &lt;div class="row"&gt;        3.定义元素        在大的显示器上显示12个格子        在pad上显示6个格子        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;        &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格系统&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;   </code></pre><p><strong>注意：</strong><br><strong>1.一行中如果格子数目超过12，则超出部分会自动换行</strong><br><strong>2.栅格类属性可以向上兼容，栅格类适用于屏幕宽度大于或等于分界点大小的设备</strong><br><strong>3.如果设备宽度小于设备，栅格类属性的代码设备的最小值，会用一个元素沾满一整行</strong>      </p><h2 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h2><h3 id="全局CSS样式"><a href="#全局CSS样式" class="headerlink" title="全局CSS样式"></a>全局CSS样式</h3><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><pre><code>class = "btn btn-default"   </code></pre><p><strong>原代码：</strong></p><pre><code>&lt;a  class="btn btn-default" href="#" &gt;Link&lt;/a&gt;&lt;button class="btn btn-default"  type="submit"&gt;Button&lt;/button&gt;&lt;input  class="btn btn-default"  type="button" value="Input"&gt;&lt;input  class="btn btn-default"  type="submit" value="Submit"&gt;</code></pre><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><pre><code>class ="img-responsive"  图片在任意尺寸都占100%  图片形状：  方形：&lt;img src="..." alt="..." class="img-rounded"&gt;  圆形：&lt;img src="..." alt="..." class="img-circle"&gt;相框：&lt;img src="..." alt="..." class="img-thumbnail"&gt;  </code></pre><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><pre><code>table   table-borderd  table-hover  </code></pre><p>原代码：  </p><pre><code>   &lt;table class="table table-bordered table-hover"&gt;    &lt;tr&gt;        &lt;th&gt;编号&lt;/th&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;年龄&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th&gt;001&lt;/th&gt;        &lt;th&gt;张三&lt;/th&gt;        &lt;th&gt;17&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;th&gt;002&lt;/th&gt;        &lt;th&gt;李四&lt;/th&gt;        &lt;th&gt;18&lt;/th&gt;    &lt;/tr&gt;    &lt;/table&gt;</code></pre><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p>给表单项添加：class=”form-control“<br>原代码：   </p><pre><code>&lt;form class="form-horizontal"&gt;&lt;div class="form-group"&gt;&lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;Email&lt;/label&gt;    &lt;div class="col-sm-10"&gt;    &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt;    &lt;/div&gt;    &lt;/div&gt;&lt;div class="form-group"&gt;&lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;Password&lt;/label&gt;    &lt;div class="col-sm-10"&gt;    &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt;    &lt;/div&gt;&lt;/div&gt;    &lt;div class="form-group"&gt;        &lt;div class="col-sm-offset-2 col-sm-10"&gt;            &lt;div class="checkbox"&gt;                &lt;label&gt;                    &lt;input type="checkbox"&gt; Remember me                &lt;/label&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class="form-group"&gt;        &lt;div class="col-sm-offset-2 col-sm-10"&gt;            &lt;button type="submit" class="btn btn-default"&gt;Sign in&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;    </code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p><strong>导航条</strong>   </p><pre><code>&lt;nav class="navbar navbar-default"&gt;&lt;div class="container-fluid"&gt;&lt;!-- Brand and toggle get grouped for better mobile display --&gt;    &lt;div class="navbar-header"&gt;        &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt;            &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt;            &lt;span class="icon-bar"&gt;&lt;/span&gt;            &lt;span class="icon-bar"&gt;&lt;/span&gt;            &lt;span class="icon-bar"&gt;&lt;/span&gt;        &lt;/button&gt;        &lt;a class="navbar-brand" href="#"&gt;Brand&lt;/a&gt;    &lt;/div&gt;    &lt;!-- Collect the nav links, forms, and other content for toggling --&gt;    &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt;        &lt;ul class="nav navbar-nav"&gt;            &lt;li class="active"&gt;&lt;a href="#"&gt;Link &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt;            &lt;li class="dropdown"&gt;                &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;                &lt;ul class="dropdown-menu"&gt;                    &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt;                    &lt;li role="separator" class="divider"&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt;                    &lt;li role="separator" class="divider"&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href="#"&gt;One more separated link&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;        &lt;/ul&gt;        &lt;form class="navbar-form navbar-left"&gt;            &lt;div class="form-group"&gt;                &lt;input type="text" class="form-control" placeholder="Search"&gt;            &lt;/div&gt;            &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt;        &lt;/form&gt;        &lt;ul class="nav navbar-nav navbar-right"&gt;            &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt;            &lt;li class="dropdown"&gt;                &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"&gt;Dropdown &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;                &lt;ul class="dropdown-menu"&gt;                    &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt;                    &lt;li role="separator" class="divider"&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt;&lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt;</code></pre><p><strong>分页条</strong>   </p><pre><code>    &lt;nav aria-label="Page navigation"&gt;&lt;ul class="pagination"&gt;    &lt;li class="disabled"&gt;        &lt;a href="#" aria-label="Previous"&gt;            &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt;        &lt;/a&gt;    &lt;/li&gt;    &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt;    &lt;li class="active"&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href="#"&gt;4&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href="#"&gt;5&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;        &lt;a href="#" aria-label="Next"&gt;            &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt;        &lt;/a&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt;</code></pre><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p><strong>轮播图</strong>   </p><pre><code>    &lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt;&lt;!-- Indicators --&gt;&lt;ol class="carousel-indicators"&gt;    &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt;    &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt;    &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt;&lt;/ol&gt;&lt;!-- Wrapper for slides --&gt;&lt;div class="carousel-inner" role="listbox"&gt;    &lt;div class="item active"&gt;        &lt;img src="img/banner_1.jpg" alt="..."&gt;        &lt;div class="carousel-caption"&gt;            ...        &lt;/div&gt;    &lt;/div&gt;    &lt;div class="item"&gt;        &lt;img src="img/banner_2.jpg" alt="..."&gt;        &lt;div class="carousel-caption"&gt;            ...        &lt;/div&gt;    &lt;/div&gt;    ...&lt;/div&gt;&lt;!-- Controls --&gt;&lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt;    &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt;    &lt;span class="sr-only"&gt;Previous&lt;/span&gt;&lt;/a&gt;&lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt;    &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt;    &lt;span class="sr-only"&gt;Next&lt;/span&gt;&lt;/a&gt;  </code></pre><p><strong>Bootstrap框架的具体操作步骤和内容都已经在官方文档中有了，官方文档写的很详细</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件监听机制</title>
      <link href="/2020/09/27/%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/09/27/%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>某些组件被执行某些操作后，触发了某些代码的执行事件</strong>   </p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>某些操作。如：单击，双击，键盘按下了，鼠标移动了</strong>     </p><h3 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h3><p><strong>组件。如：按钮，文本输入框</strong>   </p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p><strong>代码。</strong>      </p><h3 id="注册监听："><a href="#注册监听：" class="headerlink" title="注册监听："></a>注册监听：</h3><p><strong>将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码</strong>    </p><h2 id="常见的事件"><a href="#常见的事件" class="headerlink" title="常见的事件"></a>常见的事件</h2><h3 id="1-点击事件"><a href="#1-点击事件" class="headerlink" title="1.点击事件"></a>1.点击事件</h3><p><strong>onclick:单击事件</strong><br><strong>ondblclick：双击</strong>   </p><h3 id="2-焦点事件"><a href="#2-焦点事件" class="headerlink" title="2.焦点事件"></a>2.焦点事件</h3><p><strong>onblur：失去焦点</strong><br><strong>onfocus：元素获得焦点</strong>    </p><h3 id="3-加载事件"><a href="#3-加载事件" class="headerlink" title="3.加载事件"></a>3.加载事件</h3><p><strong>onload：一张页面或一幅图案加载完成</strong>     </p><h3 id="4-鼠标事件"><a href="#4-鼠标事件" class="headerlink" title="4.鼠标事件"></a>4.鼠标事件</h3><p><strong>onmousedowm：鼠标按钮被按下</strong><br><strong>onmousemove：鼠标被移动</strong><br><strong>onmouseout:鼠标从某元素移开</strong><br><strong>onmouseover：鼠标移到某元素之上</strong><br><strong>onmouseup：鼠标按键被松开</strong>   </p><h3 id="5-键盘事件"><a href="#5-键盘事件" class="headerlink" title="5.键盘事件"></a>5.键盘事件</h3><p><strong>onkeydown：某个键盘被按下</strong><br><strong>onkeyup:某个键盘被松开</strong><br><strong>onkeypress:某个键盘被按下并松开</strong>   </p><h3 id="6-选择和改变"><a href="#6-选择和改变" class="headerlink" title="6.选择和改变"></a>6.选择和改变</h3><p><strong>onchange：域的内容被改变</strong><br><strong>onselect：文本被选中</strong>   </p><h3 id="7-表单事件"><a href="#7-表单事件" class="headerlink" title="7.表单事件"></a>7.表单事件</h3><p><strong>onsubmit：确认按钮被点击</strong><br><strong>onreset：重置按钮被点击</strong>     </p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><pre><code>    &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;//2.一张页面或一副图像完成加载window.onload = function (){//1.失去焦点/* document.getElementById("username").onblur           =function (){    alert("失去焦点了");*///3.绑定鼠标事件    /*  document.getElementById("username").onmouseover=function (){        alert("鼠标来了")    }*/    //3.绑定鼠标事件 /*      document.getElementById("username").onmousedown=function(event){        alert(event.button);    }*/    //4.绑定键盘事件  /*   document.getElementById("username").onkeydown=function (){        alert(event.keycode);    }*/    //5.域内容被改变    document.getElementById("city").onchange=function (){        alert("改变了");    }    //6.确认按钮被点击    document.getElementById("form").onsubmit=function (){        alert("提交成功");    }}&lt;/script&gt;&lt;input type="text" id="username"&gt;&lt;form action="#" id="form"&gt;&lt;select id ="city"&gt;&lt;option&gt;---请选择---&lt;/option&gt;&lt;option&gt;---北京---&lt;/option&gt;&lt;option&gt;---上海---&lt;/option&gt;&lt;option&gt;---天津---&lt;/option&gt;&lt;/select&gt;    &lt;input type="submit" value="提交" &gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM和DOM</title>
      <link href="/2020/09/25/BOM%E5%92%8CDOM/"/>
      <url>/2020/09/25/BOM%E5%92%8CDOM/</url>
      
        <content type="html"><![CDATA[<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>Browse Object Model ：游览器对象模型</strong><br><strong>将游览器的各个部分封装成对象</strong>    </p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><strong>Window：窗口对象</strong><br><strong>Navigator：游览器对象</strong><br><strong>Screen：显示器屏幕对象</strong><br><strong>History：历史记录对象</strong><br><strong>Location：地址栏对象</strong>    </p><h3 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h3><h4 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h4><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h4><p><strong>1.与弹出框有关的方法：</strong><br><strong>显示带有一段消息和一个确认按钮的警示栏</strong><br><code>alert();</code><br><img src="/2020/09/25/BOM%E5%92%8CDOM/1.png" alt="alert();"><br><strong>显示带有一段消息以及确认按钮和取消按钮的对话框</strong><br><code>confirm();</code><br><img src="/2020/09/25/BOM%E5%92%8CDOM/2.png" alt="confirm();"><br><em>确认返回true，取消返回false</em><br><strong>显示可提示用户输入的对话框</strong><br><code>prompt("提示内容")</code><br><img src="/2020/09/25/BOM%E5%92%8CDOM/3.png" alt="prompt(&quot;提示内容&quot;)">     </p><h5 id="2-与打开关闭有关的方法"><a href="#2-与打开关闭有关的方法" class="headerlink" title="2.与打开关闭有关的方法"></a>2.与打开关闭有关的方法</h5><p><strong>打开一个新的游览器窗口，返回一个window对象</strong><br><code>open();</code><br><em>（）里可传网站的参数，可与事件一起使用</em><br><strong>关闭游览器窗口,谁调用他，他关谁</strong><br><code>close();</code>    </p><h5 id="3-与定时器有关的方法"><a href="#3-与定时器有关的方法" class="headerlink" title="3.与定时器有关的方法"></a>3.与定时器有关的方法</h5><p><strong>一次性定时器：在指定的毫秒数之后使用函数或者计算表达式</strong><br><code>setTimeOut("方法",时间)</code><br><strong>循环定时器：指定的周期来调用函数或计算表达式</strong><br><code>setInternal("方法",循环间隔时间)</code><br><strong>取消定时器</strong><br><strong>定时器会返回一个id值，再调用下列方法</strong>     </p><pre><code>cleanTimeout(id);cleanInternal(id);</code></pre><h4 id="3-属性"><a href="#3-属性" class="headerlink" title="3.属性"></a>3.属性</h4><h5 id="1-获取其他BOM对象"><a href="#1-获取其他BOM对象" class="headerlink" title="1.获取其他BOM对象"></a>1.获取其他BOM对象</h5><p><strong>获取history对象</strong><br><strong>获取dom对象</strong>    </p><h4 id="4-特点"><a href="#4-特点" class="headerlink" title="4.特点"></a>4.特点</h4><p><strong>window对象不需要创建可直接使用，如：window.方法名()</strong><br><strong>windo引用可生略</strong>     </p><h3 id="Location：地址栏对象"><a href="#Location：地址栏对象" class="headerlink" title="Location：地址栏对象"></a>Location：地址栏对象</h3><h5 id="创建-获取"><a href="#创建-获取" class="headerlink" title="创建(获取)"></a>创建(获取)</h5><p>1.window.location<br>2.location    </p><h5 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h5><p>reload():重新加载当前文档，刷新   </p><h5 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h5><p>href：返回完整对url   </p><h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>Document Object Model 文档对象模型</strong><br><strong>将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</strong>    </p><h3 id="核心DOM对象"><a href="#核心DOM对象" class="headerlink" title="核心DOM对象"></a>核心DOM对象</h3><h4 id="Document：文档对象"><a href="#Document：文档对象" class="headerlink" title="Document：文档对象"></a>Document：文档对象</h4><h5 id="1-创建-获取-：在html-dom模型中可以使用window对象来获取"><a href="#1-创建-获取-：在html-dom模型中可以使用window对象来获取" class="headerlink" title="1.创建(获取)：在html dom模型中可以使用window对象来获取"></a>1.创建(获取)：在html dom模型中可以使用window对象来获取</h5><pre><code>    window.document    document    </code></pre><h5 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2.方法"></a>2.方法</h5><p>1.获取Element对象<br><strong>根据id属性值获取元素对象，id的属性值一般唯一</strong>    </p><pre><code>    getElementById();  </code></pre><p><strong>根据元素名称获取元素对象们，返回值是一个数组</strong>    </p><pre><code>    getElementByTagName();   </code></pre><p><strong>根据Class属性值获取元素对象们，返回值是一个数组</strong>    </p><pre><code>    getElementByClassName();   </code></pre><p><strong>根据name属性获取元素对象们，返回值是一个数组</strong>   </p><pre><code>    getElementByName();   </code></pre><p>2.创建其他DOM对象   </p><pre><code>    createAttribute();    createComment();    createElement();    createTextNode();</code></pre><h4 id="Element：元素对象"><a href="#Element：元素对象" class="headerlink" title="Element：元素对象"></a><strong>Element：元素对象</strong></h4><p>1.获取：通过document来获取和创建<br>2.方法<br><strong>设置属性</strong>    </p><pre><code>    setAttribute();       如：setAttribute("href",网址);</code></pre><p><strong>删除属性</strong>   </p><pre><code>    removeAttribute();      如：removeAtttribute("href");   </code></pre><h4 id="Node-节点对象，其他5个的父对象"><a href="#Node-节点对象，其他5个的父对象" class="headerlink" title="Node:节点对象，其他5个的父对象"></a><strong>Node:节点对象，其他5个的父对象</strong></h4><p><strong>特点</strong>所有dom对象都可以被认为是一个节点<br>方法：<br><strong>CRUD dom树</strong><br><strong>删除(并返回)当前节点的指定子节点</strong><br><code>removeChild();</code></p><p><img src="/2020/09/25/BOM%E5%92%8CDOM/4.png">   </p><p><strong>向节点的子节点列表的结尾添加新的自节点</strong>    </p><p><code>appChild();</code></p><p><img src="/2020/09/25/BOM%E5%92%8CDOM/5.png"></p><p><strong>用新节点替换一个子节点</strong><br><code>replaceChild();</code>   </p><p><strong>获取父节点</strong><br><code>var div1 =div2.parentNode;</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2020/09/20/JavaScript%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/09/20/JavaScript%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>基于对象和事件驱动的语言，应用于客户端(游览器)</strong><br><strong>特点</strong><br>①交互性：信息的动态交互<br>②安全性：JavaScript不能访问本地磁盘的文件<br>③跨平台性:支持JS的游览器都可以运行<br><strong>Java和JavaScript的区别</strong><br>①JS是基于对象的，Java是面向对象的<br>②Java是强类型语言，JS是弱类型语言</p><blockquote><p>强类型语言:一个类型的变量一旦被定义了，如果不经过强制转换，那么它永远就是这个数据类型<br>弱类型语言：一个变量可以赋不同类型的值<br><code>var a = 1;</code>  <code>var b = "字符";</code>   </p></blockquote><p><strong>JavaScript的组成</strong><br>①ECMA Script<br>    —ECMA:欧洲计算机协会<br>    —由ECMA组织指定的js的语言，语句<br>②BOM<br>    —Browser object model：游览器对象模型  </p><p>③DOM<br>    —Document object model：文档对象模型   </p><h2 id="JS与HTML的结合"><a href="#JS与HTML的结合" class="headerlink" title="JS与HTML的结合"></a>JS与HTML的结合</h2><p>第一种：  </p><pre><code>&lt;script type="text/javascript"&gt;JS代码&lt;/script&gt;   </code></pre><p>第二种：   </p><pre><code>&lt;script type="text/javascript" src="路径"&gt; 不要在此写JS代码（因为不会运行）&lt;/script&gt;    </code></pre><h2 id="JS的原始类型和声明变量"><a href="#JS的原始类型和声明变量" class="headerlink" title="JS的原始类型和声明变量"></a>JS的原始类型和声明变量</h2><p><strong>5种原始类型</strong><br>① String<br><code>var str = "abc";</code><br>② number<br><code>var n =123;</code><br>③ boolean<br><code>var flag =true;</code><br>④ null<br><code>var a =null;</code><br>⑤ undifined(定义一个变量，没有赋值)<br><code>var aa;</code><br><strong>查看变量的类型</strong><br><code>typeof(变量名称);</code>     </p><h2 id="JS的语句"><a href="#JS的语句" class="headerlink" title="JS的语句"></a>JS的语句</h2><p>JS种有if，switch，for ，while，do…while语句    </p><h2 id="JS的运算符"><a href="#JS的运算符" class="headerlink" title="JS的运算符"></a>JS的运算符</h2><p><strong>==和===的区别</strong>   </p><blockquote><p>1.都是做判断用的<br>2.==比较的是值，===比较的是值和类型<br><strong>直接向页面输出变量和或H5代码</strong><br><code>document.write();</code>   </p></blockquote><h2 id="JS的数组"><a href="#JS的数组" class="headerlink" title="JS的数组"></a>JS的数组</h2><p>第一种：   </p><pre><code>var arr =[1,2,3];var arr =[1,"2",true];</code></pre><p>第二种:使用内置对象，Array对象    </p><pre><code>var arr1 = new Array(5);arr1[0]="1";</code></pre><p>第三种：  </p><pre><code>    var arr2 = new Array(3，4，5);    定义一个数组，其元素为3，4，5    </code></pre><p><strong>JS数组的属性</strong><br>① length<br>② 长度可变<br>③ 可存放不同的数据类型 </p><h2 id="JS的函数"><a href="#JS的函数" class="headerlink" title="JS的函数"></a>JS的函数</h2><p>① 使用关键字function   </p><pre><code>function 方法名(参数列表){方法体;返回值可有可无；}</code></pre><p>② 匿名函数  </p><pre><code>var add = function(参数){    方法体;}</code></pre><h2 id="JS的String对象"><a href="#JS的String对象" class="headerlink" title="JS的String对象"></a>JS的String对象</h2><p>① 创建String对象   </p><pre><code>var str = "abc";</code></pre><p>② 方法<br><strong>与HTML相关的方法</strong><br><em>document.write()为打印方法，为了理解这些方法，使用了打印效果</em>   </p><pre><code>//加粗document.write(str.bold());//设置字体的颜色   document.write(str.fontcolor("red"));//设置字体的大小   document.write(str.fontsize(5));//将字符串显示成超链接效果   document.write(str.link());//下标，上标   document.write(str.sub());document.write(str.sup());   </code></pre><p><strong>与Java类似的方法</strong><br>——concat；连接字符串    </p><pre><code>    document.write(str1.concat(str2));   </code></pre><p>——charAt()；返回指定位置的字符串   </p><pre><code>document.write(str.charAt(5));</code></pre><p>——indexof()；返回字符串的位置   </p><pre><code>document.write(str.indexof("a"));   </code></pre><p>——split();切分字符串成数组    </p><pre><code>    var str ="a-b-c";    var str1 =str.split("-");//a,b,c  </code></pre><p>——replace();替换字符串   </p><pre><code>document.write(str.replace("a","q"));//将q替换为a    </code></pre><p>——substr()和subString  </p><pre><code>str.substr(5,3);//从第5位到向后的3位str.subString(3,5);//从第3位到第5位   </code></pre><h2 id="JS的Array对象"><a href="#JS的Array对象" class="headerlink" title="JS的Array对象"></a>JS的Array对象</h2><p><strong>属性：length</strong><br><strong>方法</strong><br>数组的连接：   </p><pre><code>var arr1 = [1,2,3];var arr2 = [4,5,6];document.write(arr.conncat(arr2));</code></pre><p>根据指定的字符分割数字   </p><pre><code>document.write(arr1.join("-"));</code></pre><p>向数组的末尾添加新元素，返回数组的长度    </p><pre><code> var a =arr1.push("a");</code></pre><p>删除最后一个元素，返回删除的元素   </p><pre><code>var b = arr1.pop();  </code></pre><p>反转元素   </p><pre><code>document.write(arr1.reserve());   </code></pre><h2 id="JS的Math对象"><a href="#JS的Math对象" class="headerlink" title="JS的Math对象"></a>JS的Math对象</h2><p><strong>数学的运算</strong><br><strong>里面都是静态方法。使用Math.方法()</strong><br>向上舍入：<code>Math.ceib(x);</code>    <em>如10.5=11</em><br>向下舍入：<code>Math.floor(x)</code><br>四舍五入：<code>Math.round(x)</code><br>得到一个随机数：<code>Math.random();</code><br>x的y次方：<code>Math.pow(x,y)</code>   </p><h2 id="JS的全局函数"><a href="#JS的全局函数" class="headerlink" title="JS的全局函数"></a>JS的全局函数</h2><p>对字符进行编码   <code>encodeURI();</code><br>对字符进行解码   <code>decodeURI();</code><br>判断是否为字符   <code>isNaN();</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML和CSS</title>
      <link href="/2020/09/20/HTML%E5%92%8CCSS/"/>
      <url>/2020/09/20/HTML%E5%92%8CCSS/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML的表单标签"><a href="#HTML的表单标签" class="headerlink" title="HTML的表单标签"></a>HTML的表单标签</h2><p><strong>表单：用于采集用户输入的数据的，用于和服务器交互</strong><br><strong>from：用于定义表单的，可以定义一个范围，范围代表采集用户数据的范围</strong><br><strong>属性</strong><br><strong>action：</strong>指定提交数据的URL<br><strong>method：</strong> 指定提交方式<br>分为7种类，常用两种：get和post    </p><blockquote><p>1.get提交地址栏会携带提交的数据，post不会携带<br>2.get请求安全级数较低，post较高<br>3.get请求数据大小有限制，post没有   </p></blockquote><p>演示；<br>  <img src="/2020/09/20/HTML%E5%92%8CCSS/1.png">   </p><p>  <strong>这方式为post，点击注册后会将账号和密码显示在地址栏中，而get则不会。注意：表单数据提交的时候，需指定name属性。</strong>       </p><p>代码：  </p><pre><code>&lt;form method="get"&gt;账号：&lt;input type="text" name="name"/&gt;&lt;br/&gt;密码：&lt;input type="password" name ="pwd"/&gt;&lt;br/&gt;&lt;input type="submit" value="注册"/&gt;&lt;input type="reset" value="重置"/&gt;&lt;/form&gt;  </code></pre><hr><p>另外再介绍几种HTML常用的标签    </p><blockquote><p><strong>重置按钮:</strong><code>&lt;input type="reset" value="重置"/&gt;</code>    </p></blockquote><blockquote><p><strong>普通按钮:</strong><code>&lt;input type="button" value="按钮名称"/&gt;</code> </p></blockquote><blockquote><p><strong>加粗:</strong>  <code>&lt;b&gt;加粗的内容&lt;/b&gt;</code>  </p></blockquote><blockquote><p><strong>删除线:</strong> <code>&lt;s&gt;内容&lt;/s&gt;</code>  </p></blockquote><blockquote><p><strong>下划线:</strong> <code>&lt;u&gt;内容&lt;/u&gt;</code></p></blockquote><blockquote><p><strong>段落标签：</strong><code>&lt;p&gt;内容&lt;/p&gt;</code></p></blockquote><blockquote><p><strong>斜体：</strong><code>&lt;i&gt;内容&lt;/i&gt;</code>  </p></blockquote><blockquote><p><strong>div:</strong><code>&lt;div&gt;自动换行&lt;/div&gt;</code>  </p></blockquote><blockquote><p><strong>在一行内显示</strong><code>&lt;span&gt;内容&lt;/span&gt;</code>   </p></blockquote><hr><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS的简介"><a href="#CSS的简介" class="headerlink" title="CSS的简介"></a>CSS的简介</h2><p><strong>CSS</strong>：层叠样式表     </p><blockquote><p>层叠：一叠一叠的<br>样式表：很多的属性和属性值<br><strong>让页面变得更好看，CSS将网页内容和显示样式进行分离，提高了显示功能</strong>    </p></blockquote><h2 id="CSS和HTML的结合方式"><a href="#CSS和HTML的结合方式" class="headerlink" title="CSS和HTML的结合方式"></a>CSS和HTML的结合方式</h2><p><strong>内联样式</strong><br><em>在每个HTML标签上都有一个属性style，将CSS与HTML结合起来</em>      </p><pre><code>&lt;div style="color=red;"&gt;hello css&lt;/div&gt;  </code></pre><p><strong>内部样式</strong><br><em>在head标签内，定义style标签，style标签的标签体的内容为CSS代码</em>   </p><pre><code>&lt;style&gt;    div{        color:blue;    }&lt;/style&gt;&lt;div&gt;hello css&lt;/div&gt;   </code></pre><p><strong>外部样式</strong><br>1.定义css资源文件<br>2.在head标签内，定义link标签，引入外部的资源文件<br>如：a.css文件：   </p><pre><code>div{    color:green;}</code></pre><p>HTML文件中；   </p><pre><code>&lt;div&gt;hello css&lt;/div&gt;</code></pre><p>注意：<br>    ①1，2，3种方式，css作用范围越来越大<br>    ②第一种方式不常用，后期常用2，3<br>    ③第三种格式可以写为：<br>        <code>&lt;style&gt;</code><br>            <code>@inport "css/a.css";</code><br>        <code>&lt;/style&gt;</code></p><h2 id="CSS的选择器"><a href="#CSS的选择器" class="headerlink" title="CSS的选择器"></a>CSS的选择器</h2><p><strong>筛选具有相似特征的元素</strong><br><strong>基础选择器</strong><br>① id选择器    </p><pre><code>——&lt;div id ="haha"&gt;AAA&lt;/div&gt; ——#haha {    background-color:black;}</code></pre><p>② class选择器   </p><pre><code>——&lt;div class="hehe"&gt;BBB&lt;/div&gt;——.hehe{    background-color:green;}</code></pre><p>③ 标签选择器    </p><pre><code>——&lt;div&gt;CCC&lt;/div&gt;  ——div{    background-color:gray;}</code></pre><p><strong>扩展选择器</strong><br>①关联选择器   </p><pre><code>——&lt;div&gt;&lt;p&gt;DDD&lt;p&gt;&lt;div&gt; ——div p{    background:color:green;}</code></pre><p>②组合选择器   </p><pre><code>——&lt;div&gt;111&lt;/div&gt;    &lt;p&gt;222&lt;/p&gt;——div,p{    background-color:black;}</code></pre><p>③伪元素选择器<br>超链接状态：</p><pre><code> ——&lt;a&gt;链接文字&lt;/a&gt;    —— 原始状态:a.link{} 悬浮状态:a.hover{}    点击状态:a.active{}    点击之后:a.visited{}   </code></pre><h2 id="CSS的盒子模型"><a href="#CSS的盒子模型" class="headerlink" title="CSS的盒子模型"></a>CSS的盒子模型</h2><p><strong>在进行布局前需要把数据封装为一块一块的区域内</strong>     </p><p><img src="/2020/09/20/HTML%E5%92%8CCSS/2.png"><br>1⃣️ 边框<br>border： 2px solid blue;<br>border:统一设置<br>上 border-top<br>下 border-bottom<br>左 border-left<br>右 border-right<br>2⃣️ 内边距<br>padding:20px;<br>使用padding分别统一设置，如border也可分别设置<br>3⃣️ 外边距<br>margin： 20px；<br>可以使用margin统一设置，如border也可分别设置   </p><h2 id="CSS的漂浮模型"><a href="#CSS的漂浮模型" class="headerlink" title="CSS的漂浮模型"></a>CSS的漂浮模型</h2><p>float：属性值<br>left：文本流向对象的右边<br>right：文本流向对象的左边   </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML简介</title>
      <link href="/2020/09/17/HTML%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/09/17/HTML%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java-web"><a href="#java-web" class="headerlink" title="java web"></a>java web</h1><h2 id="Web概念概述"><a href="#Web概念概述" class="headerlink" title="Web概念概述"></a>Web概念概述</h2><p>Java Web：使用Java语言开发基于互联网的项目   </p><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p><strong>1.C/S：Client/Server：客户端/服务器端</strong><br>在用户本地有一个客户端程序，在远程有一个服务器端程序。如：QQ<br>优点：1.用户体验好<br>缺点：1.开发，安装，部署，维护麻烦<br><strong>2.B/S：Brower/Server：游览器/服务器端</strong><br>只需要一个游览器，用户通过不同的网址（URL），客户端访问不同的服务器端程序<br>优点：1.开发，安装，部署，维护简单<br>缺点：1.如果应用过大，用户的体验可能会收到影响<br>    2.对硬件要求额高<br><strong>B/S架构详解</strong><br>资源分类：<br><strong>1静态资源</strong>：使用静态网页开发技术发布的资源<br><strong>特点：</strong><br>1⃣️ <strong>所有用户访问，得到的结果是一样的</strong><br>如：文本，图片，音频，视频，HTML，CSS<br>2⃣️ 如果用户请求的是静态资源，那么服务器会直接将静态资源发给游览器。游览器中内置了静态资源的解析引擎可以展示静态资源<br><strong>2:使用动态网页</strong><br>使用动态网页及时发布的资源<br><strong>特点：</strong><br>1⃣️ <strong>所有用户访问得到的结果可能不一样</strong><br>如：Jsp/Servlet，php，asp<br>2⃣️ 如果用户请求的是动态资源，那么服务器会执行动态资源，<strong>转换为静态资源，再发送给游览器</strong><br><strong>静态资源</strong><br>HTML：用于搭建<strong>基础网页</strong>，展示页面内容<br>CSS：用于<strong>美化页面，布局页面</strong><br>JavaScript：控制页面的元素，让页面有一些<strong>动态的效果</strong>      </p><h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h3><p><strong>最基础的网页开发语言</strong><br><strong>Hyper Text Markup Language</strong><br><strong>A；超文本：</strong>超出文本的范畴，使用html可轻松实现这样的操作<br><strong>B：标记：</strong>html所有的操作都是通过标记实现的，标记就是标签<br><strong>C：网页语言：</strong>  </p><h3 id="2-html的规范"><a href="#2-html的规范" class="headerlink" title="2.html的规范"></a>2.html的规范</h3><p>1⃣️ 一个html文件开始标签和结束的标签    </p><pre><code>&lt;html&gt;&lt;/html&gt;  </code></pre><p>2⃣️ html包含两部分内容：     </p><pre><code>&lt;head&gt;设置相关信息&lt;head&gt;    &lt;body&gt;显示在页面上的内容都写在body里面&lt;/body&gt;   </code></pre><p>3⃣️ 标签要成对存在，又开始也有结束<br>4⃣️ html的代码不区分大小写<br>5⃣️ 有此标签，没有结束标签    </p><pre><code>如： &lt;br/&gt;</code></pre><h3 id="3-html的操作思想"><a href="#3-html的操作思想" class="headerlink" title="3.html的操作思想"></a>3.html的操作思想</h3><p>使用标签将其包装起来，<strong>通过修改标签的属性值实现标签内数据样式的变化</strong><br>一个标签相当于一个容器，<strong>想要修改容器内数据的样式，只需要改容器的属性值</strong>     </p><h2 id="HTML常用的标签"><a href="#HTML常用的标签" class="headerlink" title="HTML常用的标签"></a>HTML常用的标签</h2><h3 id="1-文字标签：修改文字的样式"><a href="#1-文字标签：修改文字的样式" class="headerlink" title="1.文字标签：修改文字的样式"></a><strong>1.文字标签：修改文字的样式</strong></h3><pre><code>    &lt;font&gt;&lt;/font&gt;     属性：      size：文字的大小  取值：1～7       color：文字颜色        1.英文单词：blue，black           2.采用十六进制数表示：#ffffff   </code></pre><h3 id="2-注释："><a href="#2-注释：" class="headerlink" title="2.注释："></a><strong>2.注释：</strong></h3><pre><code>  &lt;!-- 注释 --&gt;  </code></pre><h3 id="3-标题标签，水平线标签和特殊字符"><a href="#3-标题标签，水平线标签和特殊字符" class="headerlink" title="3.标题标签，水平线标签和特殊字符"></a><strong>3.标题标签，水平线标签和特殊字符</strong></h3><pre><code>标题标签：&lt;h1&gt;&lt;/h1&gt;        &lt;h2&gt;&lt;/h2&gt;        ......        &lt;h6&gt;&lt;/h6&gt;水平线标签：&lt;hr/&gt;           属性：size  color           eg：&lt;hr size="5" color="blue"/&gt;   特殊字符： &lt; : &amp;lt     &gt; : &amp;gt          空格: &amp;nbsp   &amp; : &amp;amp   </code></pre><h3 id="4-列表标签"><a href="#4-列表标签" class="headerlink" title="4.列表标签"></a><strong>4.列表标签</strong></h3><p>1⃣️dl标签：<br><img src="/2020/09/17/HTML%E7%AE%80%E4%BB%8B/1.png">  </p><pre><code>    &lt;dl&gt;        &lt;dt&gt;传智播客&lt;/dt&gt;        &lt;dd&gt;财务部&lt;/dd&gt;        &lt;dd&gt;人事部&lt;/dd&gt;      &lt;/dl&gt;  </code></pre><p>2⃣️.ol标签：<br><img src="/2020/09/17/HTML%E7%AE%80%E4%BB%8B/2.png">     </p><pre><code>&lt;ol&gt;    &lt;li&gt;财务部&lt;/li&gt;    &lt;li&gt;学工部&lt;/li&gt;    &lt;li&gt;人事部&lt;/li&gt;&lt;/ol&gt;</code></pre><p>3⃣️，有特殊符号   </p><p><img src="/2020/09/17/HTML%E7%AE%80%E4%BB%8B/3.png"></p><pre><code>&lt;ul type = disc&gt;    &lt;li&gt;财务部&lt;/li&gt;    &lt;li&gt;学工部&lt;/li&gt;&lt;/ul&gt;*type: 空心圆：circle   实心圆：disc（默认）        空心方块：square   </code></pre><h3 id="5-图像标签"><a href="#5-图像标签" class="headerlink" title="5.图像标签"></a><strong>5.图像标签</strong></h3><pre><code>&lt;img src="图片的路径" 其他/&gt;  其他：wide=” “     height=” “        alt=”图片上的文字 “</code></pre><h3 id="6-超链接标签"><a href="#6-超链接标签" class="headerlink" title="6.超链接标签"></a><strong>6.超链接标签</strong></h3><p>1⃣️<strong>链接资源</strong>  </p><pre><code>&lt;a href="路径" target=“_blank” 文字&gt;  &lt;/a&gt;  </code></pre><p>2⃣️<strong>定位资源</strong><br>回到顶部：</p><pre><code>&lt;a href="#top"&gt;链接中的文字&lt;/a&gt;  </code></pre><p>3⃣️原样标签</p><pre><code>&lt;pre&gt; &lt;/pre&gt;</code></pre><h3 id="7-表格标签"><a href="#7-表格标签" class="headerlink" title="7.表格标签"></a><strong>7.表格标签</strong></h3><p><img src="/2020/09/17/HTML%E7%AE%80%E4%BB%8B/4.png">   </p><pre><code>&lt;table border="2" bordercolor="" width="200" height="200" cellspacing="0"&gt;&lt;tr&gt; &lt;td&gt;一号&lt;/td&gt; &lt;td&gt;二号&lt;/td&gt; &lt;/tr&gt;&lt;tr&gt; &lt;td&gt;内容&lt;/td&gt; &lt;td&gt;内容&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;</code></pre><p><strong>参数</strong><br> -table 表格线<br> -tablecolor 表格线颜色<br> -cellspacing  单元格之间的距离<br> -width 表格的宽度<br> -hight 表格的高度    </p><h4 id="居中加粗"><a href="#居中加粗" class="headerlink" title="居中加粗"></a><strong>居中加粗</strong></h4><pre><code>&lt;th&gt; &lt;/th&gt;   </code></pre><h4 id="表格的表头"><a href="#表格的表头" class="headerlink" title="表格的表头"></a><strong>表格的表头</strong></h4><pre><code>&lt;caption&gt;内容&lt;/caption&gt;</code></pre><h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a><strong>合并单元格</strong></h4><pre><code>跨列： &lt;td rowspan="3"&gt;跨行： &lt;td clospan="2"&gt;  </code></pre><h3 id="8-表单"><a href="#8-表单" class="headerlink" title="8.表单"></a><strong>8.表单</strong></h3><h4 id="普通输入项："><a href="#普通输入项：" class="headerlink" title="普通输入项："></a><strong>普通输入项：</strong></h4><pre><code>&lt;input type="text" name="name"/&gt;  </code></pre><h4 id="密码输入项："><a href="#密码输入项：" class="headerlink" title="密码输入项："></a><strong>密码输入项：</strong></h4><pre><code>&lt;input type="password" name="pwd"/&gt;</code></pre><h4 id="单选输入项："><a href="#单选输入项：" class="headerlink" title="单选输入项："></a><strong>单选输入项：</strong></h4><pre><code>&lt;input type="radio" check="check"/&gt;check为默认选中  </code></pre><h4 id="复选输入项："><a href="#复选输入项：" class="headerlink" title="复选输入项："></a><strong>复选输入项：</strong></h4><pre><code>&lt;input type="checkbox"/&gt;   在里面需要输入相同的name属性值  </code></pre><h4 id="文件输入项："><a href="#文件输入项：" class="headerlink" title="文件输入项："></a><strong>文件输入项：</strong></h4><pre><code>&lt;input type="file"&gt;   </code></pre><h4 id="下拉输入项："><a href="#下拉输入项：" class="headerlink" title="下拉输入项："></a><strong>下拉输入项：</strong></h4><p><img src="/2020/09/17/HTML%E7%AE%80%E4%BB%8B/5.png">  </p><pre><code>&lt;select name="birth"&gt;&lt;option value="1991" select="select"&gt;1991&lt;/option&gt;&lt;option value="1992"&gt;1992&lt;/option&gt;&lt;option value="1993"&gt;1993&lt;/option&gt;&lt;/select&gt;</code></pre><p><em>select为默认选择项</em>   </p><h4 id="文本域："><a href="#文本域：" class="headerlink" title="文本域："></a><strong>文本域：</strong></h4><p><img src="/2020/09/17/HTML%E7%AE%80%E4%BB%8B/6.png">  </p><pre><code>&lt;textarea cols="100" rows="10"&gt;内容&lt;/textarea&gt;  </code></pre><p>😊😄😉  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring JDBC</title>
      <link href="/2020/09/15/Spring%20Jdbc/"/>
      <url>/2020/09/15/Spring%20Jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><p><strong>Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简单化JDBC的开发</strong>   </p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>①导入jar包<br>②创建JdbcTemplate对象，依赖数据源DataSource  </p><pre><code>JdbcTemplate template = new JdbcTemplate(ds);  </code></pre><p>③调用JdbcTemplate的方法来完成CRUD的操作  </p><h2 id="update"><a href="#update" class="headerlink" title="update():"></a><strong>update()</strong>:</h2><p>执行DML语句（增删改语句）   </p><pre><code>    //1.修改一号的数据salary为1000   @Test   public void test1(){    //1.获取JDBCTemplate对象    JdbcTemplate template = new JdbcTemplate( utils.getDataSource() );    //2.定义SQL    String sql ="update emp set salary=1000 where id =1001";    //3.执行SQL    int count = template.update( sql );    System.out.println(count);}    //2.添加一条记录    @Test   public void test2(){        JdbcTemplate template = new JdbcTemplate( utils.getDataSource() );        String sql ="insert into emp(id,ename,dept_id) values(?,?,?)";        int count = template.update( sql, 1015, "guojing", 10 );        System.out.println(count);   }    //3.删除刚才添加的记录    @Test    public void test3(){        String sql= "delete from emp where id =?";        int count =template.update( sql,1015 );        System.out.println(count);     }</code></pre><h2 id="queryForMap"><a href="#queryForMap" class="headerlink" title="queryForMap()"></a><strong>queryForMap()</strong></h2><p>查询结果将结果封装为Map集合：<br><strong>将列名作为Key，将值作为value，将这条记录封装为一个Map集合。</strong><br><strong>注意：这个方法查询的结果长度只可为1</strong>   </p><pre><code>//4.查询id=1的记录，并将其封装为Map集合    @Test    public void test4(){       String sql ="select * from emp where id =?";        Map&lt;String, Object&gt; map = template.queryForMap( sql, 1001 );        System.out.println(map);    }</code></pre><h2 id="queryForList"><a href="#queryForList" class="headerlink" title="queryForList()"></a><strong>queryForList()</strong></h2><p>查询结果将结果封装为List集合<br><strong>注：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</strong>  </p><pre><code>     //5.查询所有记录，将其封装为List    @Test    public void test5(){       String sql="select * from emp";        List&lt;Map&lt;String, Object&gt;&gt; maps = template.queryForList( sql );        for (Map&lt;String, Object&gt; map : maps) {            System.out.println(map);        }    }</code></pre><h2 id="query"><a href="#query" class="headerlink" title="query();"></a><strong>query();</strong></h2><p>查询结果，将结果封装为JavaBean对象<br><strong>query的参数：ROwMapper</strong>  </p><pre><code>        @Test     public void  test6(){   String sql ="select * from emp";   List&lt;Emp&gt; list=template.query( sql, new RowMapper&lt;Emp&gt;() {           @Override           public Emp mapRow(ResultSet rs, int i) throws SQLException {               Emp emp = new Emp();               int id = rs.getInt("id");               String  ename=rs.getString( "ename" );               int job_id = rs.getInt( "job_id" );               int mgr = rs.getInt( "mgr" );               Date joindate = rs.getDate( "joindate" );               double salary = rs.getDouble( "salary" );               double bonus = rs.getDouble( "bonus" );               int dept_id = rs.getInt( "dept_id" );               emp.setId( id );               emp.setEname( ename );               emp.setMgr( mgr);               emp.setDept_id( dept_id );               emp.setBouns( bonus );               emp.setJoindate( joindate );               emp.setSalary( salary );               emp.setJob_id( job_id );               return emp;           }       } );        for (Emp emp : list) {            System.out.println(emp);        }    }</code></pre><p><strong>一般我们使用BeanPropertyRowRapper实现类，可以完成数据到JavaBean的自动封装</strong><br><strong>new BeanPropertyRowRapper&lt;类型&gt;(类型.class)</strong>    </p><pre><code>       @Test    public void  test7(){        String sql ="select * from emp";        List&lt;Emp&gt; list=template.query( sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class  ));        for (Emp emp : list) {        System.out.println(emp);        }</code></pre><h2 id="queryForObject"><a href="#queryForObject" class="headerlink" title="queryForObject()"></a><strong>queryForObject()</strong></h2><p><strong>查询结果，将结果封装为对象</strong><br><strong>一般使用于聚合函数的查询</strong>  </p><pre><code>    //7.查询总记录数    @Testpublic void test8(){        String  sql ="select count(id) from emp";        Long total = template.queryForObject( sql, long.class );        System.out.println(total);   }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池</title>
      <link href="/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h3 id="1-概念：其实就是一个容器-集合-，存放数据库连接的容器"><a href="#1-概念：其实就是一个容器-集合-，存放数据库连接的容器" class="headerlink" title="1.概念：其实就是一个容器(集合)，存放数据库连接的容器"></a><strong>1.概念：其实就是一个容器(集合)，存放数据库连接的容器</strong></h3><p><strong>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取一些连接对象，用户访问完之后，会将连接对象归还给容器</strong>  </p><h3 id="2-好处"><a href="#2-好处" class="headerlink" title="2.好处"></a><strong>2.好处</strong></h3><p>①节约资源<br>②用户访问高效  </p><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a><strong>3.实现</strong></h3><p>1.标准接口：DataSource（java.sql包下）<br><strong>方法：</strong><br><strong>获取连接：getConnection();</strong><br><strong>归还连接：Connection.close();</strong><br><em>如果连接对象Connection是从连接池中获取的，那么调用Connection,close（）方法，则不会再关闭连接，而是归还连接</em><br>2.一般我们不会用去实现它，有数据量厂商来实现<br>①<strong>C3P0</strong>：数据库连接池技术<br>②<strong>Druid</strong>：数据库连接池实现技术，由阿里巴巴提供</p><h3 id="4-C3P0的使用"><a href="#4-C3P0的使用" class="headerlink" title="4.C3P0的使用"></a><strong>4.C3P0的使用</strong></h3><p>步骤：<br>1.导入jar包(三个)：<br>c3p0-0.9.5.2.jar<br>mchange-commons-java-0.2.12.jar<br>mysql-connector-java-5.1.37-bin.jar<br>2.定义配置文件<br>名称：c3p0.properties或c3p0-config-xml<br>路径：src目录下<br>3.创建核心对象：数据库连接池对象：ComboPooledDataSource<br>4.获取连接：getConnection<br>演示：  </p><pre><code>    public static void main(String[] args) throws SQLException {    //1.获取DataSource    DataSource  ds = new ComboPooledDataSource(  );    *可在括号中传递参数*    //2.获取连接    for (int i = 0; i &lt; 13; i++) {        Connection conn = ds.getConnection();        System.out.println(i+":"+conn);        if(i==5){            conn.close();        }   } </code></pre><h3 id="5-Druid的使用"><a href="#5-Druid的使用" class="headerlink" title="5.Druid的使用"></a><strong>5.Druid的使用</strong></h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>1.导入jar包  druid-1.0.9.jar<br>2.定义配置文件（以properties形式的）<br><em>可以叫任意名称，可以放在任意目录下</em><br>3.加载配置文件.properties<br>4.加载数据库连接池对象： 通过工厂来获取.DruidDataSource<br>5.获取连接：getConnection   </p><pre><code>    public static void main(String[] args) throws Exception {    //1.导入jar包    //2.定义配置文件    //3.加载配置文件    Properties pro = new Properties(  );    InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream( "druid.properties" );    pro.load(is);    //4.获取连接池对象    DataSource ds = DruidDataSourceFactory.createDataSource( pro );    //5.获取连接    Connection conn = ds.getConnection();    System.out.println(conn);}</code></pre><h4 id="定义工具类"><a href="#定义工具类" class="headerlink" title="定义工具类"></a>定义工具类</h4><p>1.定义一个类JDBCUtils<br>2.提供静态代码块加载配置文件，初始化连接池对象<br>3.提供方法：<br>①获取连接方法：通过数据库连接池获取连接<br>②释放资源<br>③获取连接池的方法  </p><pre><code> //JDBC连接池的工具类public class uitl {//1.定义一个成员变量 DataSourceprivate static DataSource ds;static {    Properties pro = new Properties(  );    try {        //1.加载配置文件        pro.load( JDBCUtils.class.getClassLoader().getResourceAsStream(  "druid.properties") );        // 2.获取DataSource        ds= DruidDataSourceFactory.createDataSource(pro);    } catch (IOException e) {        e.printStackTrace();    } catch (Exception e) {        e.printStackTrace();    }}//获取连接public static Connection getConnection() throws SQLException {    return ds.getConnection();}//释放资源public static  void close(Statement stmt ,Connection conn) {    if (stmt != null) {        try {            stmt.close();        } catch (SQLException e) {            e.printStackTrace();        }    }    if (conn != null) {        try {            conn.close();        } catch (SQLException e) {            e.printStackTrace();        }    }}public static  void close(ResultSet rs ,Statement stmt , Connection conn) {    if (rs != null) {        try {           rs.close();        } catch (SQLException e) {            e.printStackTrace();        }    }    if (stmt != null) {        try {            stmt.close();        } catch (SQLException e) {            e.printStackTrace();        }    }    if (conn != null) {        try {            conn.close();        } catch (SQLException e) {            e.printStackTrace();        }    }}//获取连接池的方法public static DataSource getDataSource(){    return  ds;}</code></pre><p>}</p><p>实际演示：   </p><pre><code> //完成添加操作，给account添加一条操作 public static void main(String[] args) {    Connection conn = null;    PreparedStatement pstmt = null;    {        try {             //1.获取连接            conn = utils.getConnection();            //2.定义SQL            String sql = "insert into account values(null,?,?)";            //3.获取pstmt对象            pstmt = conn.prepareStatement( sql );            //4.给？赋值            pstmt.setString( 1, "wangwu" );            pstmt.setDouble( 2, 4000 );            //5.执行sql            int count = pstmt.executeUpdate();            System.out.println( count );        } catch (SQLException e) {            e.printStackTrace();        } finally {            //释放资源            utils.close( pstmt, conn );        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC入门</title>
      <link href="/2020/09/13/JDBC%E5%85%A5%E9%97%A8/"/>
      <url>/2020/09/13/JDBC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p><strong>全写：Java DataBase Connectivity 即Java数据库连接</strong><br><strong>JDBD的本质：是由官方（Sun公司）定义的一套操作系统所有关系型数据库的规则，即接口。各大数据库厂商去实现这套接口，提供了数据库驱动jar包，我们可以使用这套(JDBC)编程，真正执行代码的是驱动jar包的实现类。</strong><br><img src="/2020/09/13/JDBC%E5%85%A5%E9%97%A8/JDBC%E6%9C%AC%E8%B4%A8.jpg" alt="JDBC本质"></p><h2 id="JDBC入门"><a href="#JDBC入门" class="headerlink" title="JDBC入门"></a>JDBC入门</h2><p><strong>步骤</strong><br><strong>①导入驱动jar包</strong><br><strong>②注册驱动</strong>  </p><pre><code>Class.forName("com.mysql.jdbc.Driver");</code></pre><p><strong>③获取数据库连接对象</strong>  </p><pre><code>Connection conn = DriverMannger.getConnect("jdbc:mysql://localhost:3306/数据库名称","root","root");</code></pre><p><strong>④定义SQL语句</strong>  </p><pre><code>String sql ="SQL语句"； </code></pre><p><strong>⑤获取执行SQL的对象</strong>  </p><pre><code>Statement stmt = conn.createSatement();  </code></pre><p><strong>⑥执行SQL</strong>  </p><pre><code>int count = stmt.executeUpdate(sql);</code></pre><p><strong>⑦处理结果</strong>  </p><pre><code>System.out.println(count);</code></pre><p><strong>⑧释放资源</strong>  </p><pre><code>    stmt.close();      conn..close();   </code></pre><h2 id="详解各类对象"><a href="#详解各类对象" class="headerlink" title="详解各类对象"></a>详解各类对象</h2><h3 id="DriveMannger-：驱动管理对象"><a href="#DriveMannger-：驱动管理对象" class="headerlink" title="DriveMannger ：驱动管理对象"></a>DriveMannger ：驱动管理对象</h3><p><strong>功能：1.注册驱动：告诉程序该使用哪一个数据库驱动jar包</strong><br>注册与给定的驱动程序DriverMannger: </p><pre><code>static void registerDriver(Driver driver);  </code></pre><p>写代码时候可用：</p><pre><code>Class.forName("com.mysql.jdbc.Driver");  </code></pre><p><strong>原因：我们观察后者的源码</strong>  </p><pre><code>static {    java.sql.DriverMannger.registerDriver(new Driver);}    catch(SQLException E){        throw new RuntimeException("can't register driver");    }}</code></pre><p><em>源码中有一段和前者的方法一样的代码</em><br><strong>注：在MySQL5版本之后驱动jar包可省略驱动步骤</strong><br><strong>功能2：获取数据库连接</strong><br>方法：</p><pre><code>    static Connection getConnection(String url,String user,String password);   </code></pre><p>解释上述参数：<br>①url：指定连接的路径<br>    语法：jdbc:mysql://ip地址（域名）：端口号/数据库名称<br>    举例：jdbc:mysql://localhost:3306/db1;<br>    注意:如果连接的是本机MySQL服务器，并且MySQL服务器的默认端口是3306，则url可简写为：jdbc:mysqlL///db1;<br>②user：用户名<br>③password：密码  </p><h3 id="Connection：数据库连接对象"><a href="#Connection：数据库连接对象" class="headerlink" title="Connection：数据库连接对象"></a>Connection：数据库连接对象</h3><p><strong>功能</strong><br>①获取执行SQL的对象  </p><pre><code>Statement createStatement();   PreparedStatement prepareStatement(String sql)   </code></pre><p>②管理事务<br>1.开启事务：</p><pre><code>setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开启事务  </code></pre><p>2.提交事务  </p><pre><code>commit();  </code></pre><p>3.回滚事务  </p><pre><code>rollback();  </code></pre><h3 id="Statement-执行SQL的对象"><a href="#Statement-执行SQL的对象" class="headerlink" title="Statement:执行SQL的对象"></a>Statement:执行SQL的对象</h3><p>1.执行SQL<br>①可以执行任意的SQL  </p><pre><code>boolean execute(String sql);</code></pre><p>②执行DML(insert,update,delete)语句,DDL(create,alter,drop)语句   </p><pre><code>int exrcuteUpdate(String sql);/*返回值：影响行数，可通过影响的行数判断DML语句是否执行成功*/ </code></pre><p>③执行DQL(select)语句  </p><pre><code>ResultSet executeQuery(String sql);  </code></pre><h3 id="Result-结果集对象，封装查询结果"><a href="#Result-结果集对象，封装查询结果" class="headerlink" title="Result:结果集对象，封装查询结果"></a>Result:结果集对象，封装查询结果</h3><p><strong>1.游标向下移动一行</strong>     </p><pre><code> next();</code></pre><p><strong>2.获取数据：</strong>  </p><pre><code>getXxx();  </code></pre><p><strong>参数：1.int：代表列的编号，从1开始。 如：getString(1)</strong><br><strong>2.String：代表列的名称。如：getName(“name”);</strong><br><code>注意:使用步骤</code><br>①游标向下移动一行<br>②判断是否有数据  </p><pre><code>boolean next();</code></pre><p><em>游标向下移动一行，判断当前是否为最后一行(是否有数据)，如果是，返回true，如果否，返回false</em><br>③获取数据  </p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p><img src="/2020/09/13/JDBC%E5%85%A5%E9%97%A8/y.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的设计</title>
      <link href="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><h2 id="1-多表之间的关系"><a href="#1-多表之间的关系" class="headerlink" title="1.多表之间的关系"></a>1.多表之间的关系</h2><p>1.一对一<br>如人和身份证  </p><p><img src="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/%E4%B8%80%E5%AF%B9%E4%B8%80.jpg"><br>一个人只有一个身份证，一个身份证只能对应一个人.<br><strong>一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键</strong><br>2.一对多(多对一)<br>如：部门和员工   </p><p><img src="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/%E4%B8%80%E5%AF%B9%E5%A4%9A.jpg"><br>分析：一个部门可以有多个员工，一个员工只能对应一个部门。<br><strong>实现方式：在多的一方建立外键，指向一的一方的主键。</strong><br>3.多对多关系<br>如：学生和课程  </p><p><img src="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%A4%9A%E5%AF%B9%E5%A4%9A.jpg">  </p><p>分析：一个学生可以选择很多门课程，课程也可以被很多名学生选择<br>多对多关系需要借助第三张中间表，中间至少包含两个字段，<strong>这两个字段作为第三张表的外键，分别指向两张表的主键。</strong>   </p><h1 id="数据库设计的范式"><a href="#数据库设计的范式" class="headerlink" title="数据库设计的范式"></a>数据库设计的范式</h1><p>概念：设计数据库时，要遵循的一些规范。要遵循后面的概范要求，必须先遵循前边的所有范式要求<br><strong>六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、Boyce-Codd范式（巴斯范式/BCNF）、第四范式（4NF）和第五范式（5NF）</strong><br><em>实际学习中重点掌握前三种范式</em></p><p><strong>下面来进入主题</strong>  </p><p><img src="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E7%94%9F%E8%A1%A8.png">    </p><h2 id="2-三大范式（重点）"><a href="#2-三大范式（重点）" class="headerlink" title="2.三大范式（重点）"></a>2.三大范式（重点）</h2><h3 id="第一范式（1NF）："><a href="#第一范式（1NF）：" class="headerlink" title="第一范式（1NF）："></a>第一范式（1NF）：</h3><p><strong>每一列都是不可分割的原子数据项</strong><br><img src="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F.png"><br>在该表中我们可以看到系是可以分割为系名和系主任，即系是可分割的。所以不满组第一范式。<br><strong>此表应改为</strong><br><img src="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F2.png">  </p><p>此表存在的问题 </p><pre><code>1.存在严重的数据冗余（重复）：系名,系主任,学号,姓名  2.在数据添加时候存在问题：在添加一个新开设的系时，会存在数据不合法（无学生，学号。。。）  3.删除数据时也存在问题：张无忌同学毕业后，删除数据会将系也删除  </code></pre><h3 id="第二范式-2NF-："><a href="#第二范式-2NF-：" class="headerlink" title="第二范式(2NF)："></a>第二范式(2NF)：</h3><p><strong>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</strong><br>在了解范式之前需要明白几个函数概念 </p><h4 id="1-函数依赖"><a href="#1-函数依赖" class="headerlink" title="1 .函数依赖 :"></a>1 .函数依赖 :</h4><p><strong>A-&gt;B 如果通过A属性(属性组)的值，可以确定唯一B属性的值，则成B依赖于B</strong><br>例如：学号——&gt;姓名  （学号，课程名称）——&gt;分数<br><em>张无忌的学号可以确定他的姓名，即姓名依赖学号</em><br><em>张无忌学号和课程名称这个属性组可以确定分数，即分数依赖于学号和课程名称这个属性组</em>  </p><h4 id="2-完全函数依赖："><a href="#2-完全函数依赖：" class="headerlink" title="2.完全函数依赖："></a>2.完全函数依赖：</h4><p><strong>A——&gt;B 如果A是一个属性组，则B属性值确定需要依赖A属性组中的所有的属性值。</strong><br>例如： (学号，课程名称)——&gt;分数<br><em>张无忌的学号和课程名称可以确定他的分数，并且学号和课程名称却以不少。即分数完全依赖于学号和课程名称</em>  </p><h4 id="3-部分函数依赖："><a href="#3-部分函数依赖：" class="headerlink" title="3.部分函数依赖："></a>3.部分函数依赖：</h4><p><strong>A——&gt;B 如果A是一个属性组，则B属性值的确定只需依赖A属性组中的某一些属性值即可。</strong><br>例如 （学号，课程名称）——&gt;姓名<br><em>学号和课程姓名能推出姓名，但是前者（属性组）中有多余的推出条件。即姓名部分依赖于学号和课程姓名这个属性组</em>  </p><h4 id="4-传递函数依赖："><a href="#4-传递函数依赖：" class="headerlink" title="4.传递函数依赖："></a>4.传递函数依赖：</h4><p><strong>A——&gt;B B——C 如果通过A属性（属性组）的值可以确定唯一B属性组的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称为C传递函数依赖于A</strong><br>例如：学号-&gt;系名 系名—&gt;系主任    </p><h4 id="5-码："><a href="#5-码：" class="headerlink" title="5.码："></a>5.码：</h4><p><strong>如果在一张表中，一个属性或属性组被其他所有属性所完全依赖，则称这个属性（属性组）为改表的码</strong><br>例如：该表中的码：（学号，课程名称）<br><strong>主属性</strong>：码属性组中的所有属性<br><strong>非主属性</strong>：除过码属性组的属性<br>在该表中，主码为（学号，课程名称）主属性为学号，课程名称，其他的属性即非主属性。可以看出姓名，系名，系主任对主码是部份依赖的。可将姓名，系名，系主任和另外属性分开,并删除重复部分，这样就遵循第二范式了。  </p><p><img src="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png">   </p><h3 id="第三范式-3NF-："><a href="#第三范式-3NF-：" class="headerlink" title="第三范式(3NF)："></a>第三范式(3NF)：</h3><p><strong>在2NF上，任何非主属性不依赖于其他非主属性（在2NF基础上消除传递依赖</strong><br>观察上表，系名被学号依赖，系主任被系名依赖，所以系主任传递依赖学号。所有应将系名和系主任从学生表中分开,这样就遵循了第三范式。  </p><p><img src="/2020/09/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png">  </p><p><strong>同时上述所说的问题也将解决</strong>   </p><h2 id="3-数据库的备份和还原"><a href="#3-数据库的备份和还原" class="headerlink" title="3.数据库的备份和还原"></a>3.数据库的备份和还原</h2><p>备份：</p><pre><code>语法： mysqldump -用户名 -r密码  &gt; 保存的路径</code></pre><p>还原：<br>      1.登录数据库；<br>      2.创建database；<br>      3.使用该database；<br>      4.还原：  source + 保存的路径</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多表查询</title>
      <link href="/2020/09/10/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB/"/>
      <url>/2020/09/10/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询的分类"><a href="#多表查询的分类" class="headerlink" title="多表查询的分类"></a>多表查询的分类</h1><p><strong>这里有两张表</strong>  </p><p><img src="/2020/09/10/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB/emp.png"> <img src="/2020/09/10/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB/dept.png"> </p><p>现在我们想查询所有员工信息和对应的部门信息  </p><pre><code>SELECT * FROM EMP, DEPT;  </code></pre><p><strong>这样会产生许多的数据冗余（重复），所以可通过如下几个方法解决</strong>        </p><h2 id="1-内连接查询："><a href="#1-内连接查询：" class="headerlink" title="1.内连接查询："></a>1.内连接查询：</h2><h3 id="1-隐式内连接"><a href="#1-隐式内连接" class="headerlink" title="1.隐式内连接"></a>1.隐式内连接</h3><p> <strong>使用where条件消除无用数据</strong>    </p><p><strong>现在我们想查询所有员工信息和对应的部门信息</strong>  </p><pre><code> SELECT * FROM EMP,DEPT;  </code></pre><p><em>查出的结果为该表</em>   </p><pre><code> SELECT * FROM EMP,DEPT WHERE EMP.`DEPT.ID` = DEPT.`ID`;   </code></pre><p><em>查出的结果即为该表</em> </p><p><img src="/2020/09/10/%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%88%86%E7%B1%BB/1.png"> </p><p><strong>查询所有员工的姓名，性别，部门的名称</strong>  </p><pre><code>SELECT         t1.name,        t1.gender,        t2.name  FROM         EMP t1,        dept t2 where   t1.`dept_id` = t2.`id`</code></pre><p><em>实际开发中代码应如上格式书写</em>  </p><h3 id="2-显示内连接"><a href="#2-显示内连接" class="headerlink" title="2.显示内连接"></a>2.显示内连接</h3><p>语法：</p><pre><code>    SELECT 字段列表 FROM 表名1 [inner] join 表名2 on 条件  </code></pre><p>例如：</p><pre><code>    SELECT * FROM EMP INNER JOIN  DEPT ON EMP.`DEPT_ID` =DEPT.`ID`;  </code></pre><h3 id="3-内连接查询注意点："><a href="#3-内连接查询注意点：" class="headerlink" title="3.内连接查询注意点："></a>3.内连接查询注意点：</h3><pre><code>1.从那些表中查询数据  2.条件是什么  3.查询哪些字段  </code></pre><h2 id="2-外连接查询"><a href="#2-外连接查询" class="headerlink" title="2.外连接查询"></a>2.外连接查询</h2><h3 id="1-左外连接：查询的是左表所有数据以及其交集部分"><a href="#1-左外连接：查询的是左表所有数据以及其交集部分" class="headerlink" title="1.左外连接：查询的是左表所有数据以及其交集部分"></a>1.左外连接：查询的是左表所有数据以及其交集部分</h3><p>语法：</p><pre><code>SELECT 字段名称 FROM 表一 LEFT [OUTER] JOIN 表二 ON 条件；  </code></pre><h3 id="2-右外连接：查询的是右表所有数据以及其交集部分"><a href="#2-右外连接：查询的是右表所有数据以及其交集部分" class="headerlink" title="2.右外连接：查询的是右表所有数据以及其交集部分"></a>2.右外连接：查询的是右表所有数据以及其交集部分</h3><p>语法：</p><pre><code>SELECT 字段名称 FROM 表一 RIGHT [OUTER] JOIN 表一 ON 条件；</code></pre><p><em>右外连接和左外连接实际作用一样，左外连接只需要交换表一和表二的位置即可达成右外连接的效果</em>  </p><h2 id="3-子查询"><a href="#3-子查询" class="headerlink" title="3.子查询"></a>3.子查询</h2><p><strong>概念：查询中嵌套查询，称该查询为子查询；</strong><br>如：查询工资最大的人的信息<br>通常情况下我们会分为如下两步：  </p><pre><code>SELECT MAX(SALARY) FROM EMP;SELECT * FROM EMP WHERE 上式结果；</code></pre><p>使用子查询只需一条SQL语句：  </p><pre><code>SELECT * FROM EMP WHERE EMP.`SALARY`=(SELECT MAX(SASLARY FROM EMP));   </code></pre><p><strong>子查询的分类</strong><br><strong>1.子查询的结果可以式单列单行</strong><br>   <strong>子查询可以作为条件使用运算符去判断。运算符；&lt; &gt; + = …</strong><br>如查询员工工资小于平均工资的人：</p><pre><code>SELECT * FROM EMP WHERE EMP.SALARY &lt; (SELECT AVG(SALARY) FROM EMP);  </code></pre><p><strong>2.子查询的结果是多行单列的</strong><br><strong>子查询可以作为条件，使用运算符in来判断</strong><br>如查询<code>财务部</code>和<code>市场部</code>所有的员工信息  </p><pre><code>SELECT * FROM EMP WHERE DEPT_ID IN (SELECT ID FROM DEPT WHERE NAME=`财务部` OR NAME=`市场部`)；</code></pre><p><strong>3.查询的结果是多行多列的</strong><br><strong>子查询可以作为一张虚拟表</strong><br>如查询员工入职日期是2011-11-11日之后的员工信息和部门信息  </p><pre><code>SELECT * FROM DEPT t1.（SELECT * FROM EMP WHERE EMP JOIN_DATA &gt; `2011-11-11`） t2 WHERE t1.id =t2.dept_id;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的约束</title>
      <link href="/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%89)/"/>
      <url>/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库-三"><a href="#数据库-三" class="headerlink" title="数据库(三)"></a>数据库(三)</h1><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p> <strong>概念：对表中的数据进行限定，保证数据的正确性，有效性和完整性。</strong></p><h3 id="一-非空约束"><a href="#一-非空约束" class="headerlink" title="一.非空约束"></a>一.非空约束</h3><p>1.将name设为非空(创建时添加)  </p><pre><code>    NAME VARCHAR(20) NOT NULL;</code></pre><p>2.创建表后添加非空约束</p><pre><code>    ALTER TABLE STU MODIFY NAME VARCHAR(20) NOT NULL;</code></pre><p>3.删除name的非空约束  </p><pre><code>    ALTER TABLE STU MODIFY NAME VARCHAR(20);</code></pre><h3 id="二-唯一约束"><a href="#二-唯一约束" class="headerlink" title="二.唯一约束"></a>二.唯一约束</h3><p> UNIQUE:某一列的值不能重复<br>  <strong>注意：唯一约束可以有NULL值，但是只能有一条记录为NULL</strong><br>  1.在创建表时，条件唯一约束  </p><pre><code>    ID INT UNIQUE;</code></pre><p>2.在创建表完后，添加唯一约束  </p><pre><code>    ALTER TABLE STU DROP MODIFY ID INT UNIQUE;</code></pre><p>3.删除唯一约束  </p><pre><code>    ALTER TABLE STU DROP INDEX ID;</code></pre><h3 id="三-主键约束"><a href="#三-主键约束" class="headerlink" title="三.主键约束"></a>三.主键约束</h3><p> prinary key<br> <strong>注意：1.含义：非空且唯一； 2.一张表只能有一个字段为主键； 3.主键就是表中的唯一标识</strong><br> 1.在创建表时候，添加主键约束  </p><pre><code>    ID INT PRIMARY KEY;</code></pre><p> 2.创建表后，添加主键  </p><pre><code>    ALTER TABLE STU MODIFY ID INT PRIMARY KEY;</code></pre><p> 3.删除主键  </p><pre><code>     ALTER TABLE STU DROP PRIMARY KEY;  </code></pre><p><strong>4.自动增长</strong><br>1.概念：如果某一列是数值类型的，使用AUTO_INCREMENT ,可完成自动增长<br>2.在创建表的时候，添加主键约束，并完成主键自动增长   </p><pre><code>     ID INT PRIMARY KEY AUTO_INCREMENT;</code></pre><p>3.创建表后添加自动增长  </p><pre><code>    ALTER TABLE STU MODIEY ID INT AUTO_INCREMENT;</code></pre><p>4.删除自动增长  </p><pre><code>    ALTER TABLE STU MODIEY ID INT;</code></pre><h3 id="四-外键约束"><a href="#四-外键约束" class="headerlink" title="四.外键约束"></a><strong>四.外键约束</strong></h3><p><strong>让表与表产生关系，从而保证数据的正确性。</strong><br>1.在创建表时，添加外键  </p><pre><code>    CONSTRAINT 外键名称 FOREIGN KEY(外键列名称) REFERENCES 主表的名称（主表列名称）</code></pre><p>2.创建表后，添加外键  </p><pre><code>    ALTER TABLE 表名 ADD CONSTRANT 外键名称 FOREIGN KEY(外键字段名称) REFERENCES 主表名称（主列表名称）</code></pre><p>3.删除外键</p><pre><code>    ALTER TABLE 表名 DROP FOREIGN KEY 外键名称； </code></pre><p><strong>4.级联操作</strong><br>注意：级联操作的时候要关闭外间约束<br> 1&gt;添加级联操作  </p><pre><code>    ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段明称) REFERENCES 主表名称(主列表名称) ON UPDATE CASCADE ON DELETE CASCADE;  </code></pre><p>2&gt;分类<br>1.级联更新：ON UPDATE CASCADE;<br>2.级联删除：ON DELETE CASCADE;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DQL的查询和DCL的管理</title>
      <link href="/2020/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/"/>
      <url>/2020/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库-二"><a href="#数据库-二" class="headerlink" title="数据库(二)"></a>数据库(二)</h1><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="1-排序查询"><a href="#1-排序查询" class="headerlink" title="1.排序查询"></a>1.排序查询</h3><p><strong>语法：<br>     order by 排序字段1  排序方式1，排序字段2，排序方式2…</strong> </p><pre><code> SELECT * FROM STUDENT ORDER BY MATH ASC; /* 将数学按照升序排列 */</code></pre><p>排序方式：ASC:升序(默认)        DESC:降序<br><strong>注意：如果有多个排序条件，则当前面的条件值一样时，才会判断第二个条件</strong>  </p><pre><code>SELECT * FROM STUDENT3 ORDER BY MATH ASC, ENGLISH DESC;/*当数学的值一样的时候，才会用降序排列英语*/</code></pre><h3 id="2-聚合函数"><a href="#2-聚合函数" class="headerlink" title="2.聚合函数"></a>2.聚合函数</h3><p><strong>将一列数据作为整体，进行纵向的计算</strong>  </p><h4 id="1-count-：计算个数"><a href="#1-count-：计算个数" class="headerlink" title="1.count ：计算个数"></a>1.count ：计算个数</h4><p>1&gt;一般选择非空的列：主键<br>2&gt;count(*)<br> 2.MAX: 计算最大值<br> 3.MIN: 计算最小值<br> 4.AVG: 计算平均值<br>*注意：聚合函数的计算，排除Null值<br>解决方案：1：选择不包含非空的列进行计算<br>         2：IFNULL函数  </p><h3 id="3-分组查询"><a href="#3-分组查询" class="headerlink" title="3.分组查询"></a>3.分组查询</h3><h4 id="1-语法：group-by-分组字段；"><a href="#1-语法：group-by-分组字段；" class="headerlink" title="1.语法：group by 分组字段；"></a>1.语法：group by 分组字段；</h4><h4 id="2-注意："><a href="#2-注意：" class="headerlink" title="2.注意："></a>2.注意：</h4><ol><li>分组之后查询的字段：分组字段、聚合函数</li><li>where 和 having 的区别？  <pre><code> 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来   2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。     </code></pre></li></ol><h3 id="4-分页查询"><a href="#4-分页查询" class="headerlink" title="4.分页查询"></a>4.分页查询</h3><p> 1.语法：limit开始的索引，每页查询的条数；<br> 2.公式：开始的索引=（当前的页码-1）* 每页显示的条数  </p><pre><code>    -- 每页显示3条记录         SELECT * FROM student LIMIT 0,3; -- 第1页        SELECT * FROM student LIMIT 3,3; -- 第2页        SELECT * FROM student LIMIT 6,3; -- 第3页</code></pre><p>3.limit是MYSQL的“方言”  </p><h3 id="5-基础查询"><a href="#5-基础查询" class="headerlink" title="5.基础查询"></a>5.基础查询</h3><h4 id="1-多个字段的查询"><a href="#1-多个字段的查询" class="headerlink" title="1. 多个字段的查询"></a>1. 多个字段的查询</h4><pre><code>    select 字段名1，字段名2... from 表名；        * 注意：如果查询所有字段，则可以使用*来替代字段列表。</code></pre><h4 id="2-去除重复："><a href="#2-去除重复：" class="headerlink" title="2. 去除重复："></a>2. 去除重复：</h4><pre><code>     distinct  </code></pre><h4 id="3-计算列"><a href="#3-计算列" class="headerlink" title="3. 计算列"></a>3. 计算列</h4><pre><code>** 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）**  * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null      * 表达式1：哪个字段需要判断是否为null      * 如果该字段为null后的替换值 。  </code></pre><h4 id="4-起别名："><a href="#4-起别名：" class="headerlink" title="4. 起别名："></a>4. 起别名：</h4><p> as：as也可以省略  </p><h4 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h4><h5 id="1-where子句后跟条件"><a href="#1-where子句后跟条件" class="headerlink" title="1. where子句后跟条件"></a>1. where子句后跟条件</h5><h5 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h5><pre><code>        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !            -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;            SELECT * FROM student WHERE age &gt;= 20;            -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;            -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;            -- 查询年龄大于等于20 小于等于30            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;            -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);            -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断            SELECT * FROM student WHERE english IS NULL;            -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE '马%';            -- 查询姓名第二个字是化的人            SELECT * FROM student WHERE NAME LIKE "_化%";            -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE '___';            -- 查询姓名中包含德的人            SELECT * FROM student WHERE NAME LIKE '%德%';  </code></pre><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><p><code>DCL内容较少，实际工作DCL的操作大多数由DBA人员操作</code>  </p><p><strong>SQL的分类</strong><br><strong>1.DDL：操作数据库和表</strong><br><strong>2.DML:增删改表中的数据</strong><br><strong>3.DQL：查询表中的数据</strong><br><strong>4.DCL：管理用户，收于权限</strong>  </p><h3 id="1-管理用户"><a href="#1-管理用户" class="headerlink" title="1.管理用户"></a>1.管理用户</h3><p>  <strong>1.添加用户</strong>  </p><pre><code>     CREATE USER '用户名'@‘主机名’ IDENTIFIED BY  ‘密码’；</code></pre><p>  <strong>2.删除用户</strong>  </p><pre><code>DROP USER '用户名'@‘主机名’；  主机名处可使用同配符 % 表示在任何主机上都能访问 </code></pre><p>  <strong>3.修改密码</strong>  </p><pre><code>修改lisa密码为abc   UPDATE USER SET PASSWORD('abc') WHERE USER='用户名'；  </code></pre><p>  <strong>4.查询用户</strong>  </p><pre><code> 1.切换到mysql的数据库   USE MYSQL;   2.查询user表   SELECT * FROM USER;</code></pre><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2.权限管理"></a>2.权限管理</h3><p><strong>1.查询权限</strong>  </p><pre><code>SHOW GRANTS FOR ‘用户名’@‘主机名’；</code></pre><p><strong>2.授予权限</strong>  </p><pre><code>GRANT 权限列表 ON 数据库名.表名 to ‘用户名’@‘主机名’；</code></pre><p><strong>3.撤销权限</strong>  </p><pre><code>REVOKE 权限列表 ON 数据库.表名 FROM ‘用户名’@‘主机名’；</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL的概念和DDL</title>
      <link href="/2020/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/"/>
      <url>/2020/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="一·概念"><a href="#一·概念" class="headerlink" title="一·概念"></a>一·概念</h2><p>1.Database 简称DB<br>2.定义：用于存储和管理数据的仓库<br>3.特点：</p><pre><code>    1持久化存储数据，即文件系统。    2方便存储和管理数据。    3使用统一的方式存储数据库（SQL）</code></pre><h2 id="二·SQL"><a href="#二·SQL" class="headerlink" title="二·SQL"></a>二·SQL</h2><h3 id="1·什么是SQL？"><a href="#1·什么是SQL？" class="headerlink" title="1·什么是SQL？"></a>1·什么是SQL？</h3><p>Structured Query Language：结构化查询语言<br>即：定义了操作所有关系型数据库的规则，每种数据库的操作方式相当于一种”方言”  </p><h3 id="2·SQL的通用语法"><a href="#2·SQL的通用语法" class="headerlink" title="2·SQL的通用语法"></a>2·SQL的通用语法</h3><pre><code>1.SQL的语句可以单行和多行书写，以分号结尾。2.可以使用空格和缩进来增强语句的可读性。3.三种注释       单行注释：  -- 注释内容           #注释内容多行注释：  /*注释内容*/</code></pre><h2 id="三·SQL的分类"><a href="#三·SQL的分类" class="headerlink" title="三·SQL的分类"></a>三·SQL的分类</h2><h3 id="1-DDL-Data-Definition-Language-数据定义语言"><a href="#1-DDL-Data-Definition-Language-数据定义语言" class="headerlink" title="1) DDL(Data Definition Language)数据定义语言"></a>1) DDL(Data Definition Language)数据定义语言</h3><p>用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等  </p><h4 id="操作数据库（CRUD）"><a href="#操作数据库（CRUD）" class="headerlink" title="操作数据库（CRUD）"></a>操作数据库（CRUD）</h4><h6 id="1-gt-C（create）-创建"><a href="#1-gt-C（create）-创建" class="headerlink" title="1>C（create）:创建"></a>1&gt;C（create）:创建</h6><p>  <strong>创建数据库:</strong>      create database 数据库名称;</p><p>  <strong>创建数据库，并选择字符格式：</strong>  create database 数据库名称 character set 字符集名称;</p><h6 id="2-gt-R（retrieve）：查询"><a href="#2-gt-R（retrieve）：查询" class="headerlink" title="2>R（retrieve）：查询"></a>2&gt;R（retrieve）：查询</h6><p>  <strong>查询所有数据库的名称：</strong> show databases;</p><p>  <strong>查询某个数据库的字符集：</strong> show create database 数据库名称;</p><h6 id="3-gt-U-update-修改"><a href="#3-gt-U-update-修改" class="headerlink" title="3>U(update):修改"></a>3&gt;U(update):修改</h6><p>  <strong>修改数据库的字符集：</strong> alter database 数据库名称 character set 字符集名称；</p><h6 id="4-gt-D-delete"><a href="#4-gt-D-delete" class="headerlink" title="4>D(delete)"></a>4&gt;D(delete)</h6><p>  <strong>删除数据库：</strong>   drop database 数据库名称；<br>  <strong>判断数据库是否存在再删除：</strong> drop database if exists 数据库名称；</p><h6 id="5-gt-使用数据库"><a href="#5-gt-使用数据库" class="headerlink" title="5>使用数据库"></a>5&gt;使用数据库</h6><p>  <strong>查询当前正在使用的数据库名称：</strong>  select database();</p><p>  <strong>使用数据库：</strong> use 数据库名称；  </p><h4 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h4><h5 id="1-gt-C（create）：创建"><a href="#1-gt-C（create）：创建" class="headerlink" title="1>C（create）：创建"></a>1&gt;C（create）：创建</h5><p>  语法：   </p><pre><code>   create table 表名（            列表1 数据类型1，            列表2 数据类型2，            。。。 。。。            列表n 数据类型n              ）      注意：最后一列不加逗号        /*数据类型：      int 整数类型（age int）     double 小数类型 （score double）      date 日期，只包含年月日yyyy-MM-dd      datetime 日期，包含年月日时分秒 yyyy-MM-dd HH:MM:ss      timestamp 时间错类型 包含年月日时分秒 yyyy-MM-dd HH:MM:ss       如果不给该字段或为Null,则默认使用当前的系统时间来自动赋值        */   </code></pre><p>   代码实现：  </p><pre><code>  create table student (    id  int,    name varchar(32),    age int,    score double(4,1),    birthday date,    insert_time timestamp  );</code></pre><p>   复制表： create table 表名 like 被复制的表名  </p><h5 id="2-R（retrieve）：查询"><a href="#2-R（retrieve）：查询" class="headerlink" title="2.R（retrieve）：查询"></a>2.R（retrieve）：查询</h5><p>  查询某个数据库中所有的表名称：show tables;<br>  查询表结构：desc 表名；</p><h5 id="3-U（update）：修改"><a href="#3-U（update）：修改" class="headerlink" title="3.U（update）：修改"></a>3.U（update）：修改</h5><h6 id="1-gt-修改表名：alter-table-表名-rename-to-新的表名；"><a href="#1-gt-修改表名：alter-table-表名-rename-to-新的表名；" class="headerlink" title="1>修改表名：alter table 表名 rename to 新的表名；"></a>1&gt;修改表名：alter table 表名 rename to 新的表名；</h6><h6 id="2-gt-修改表的字符集：-alter-table-表名-character-set-字符集名称；"><a href="#2-gt-修改表的字符集：-alter-table-表名-character-set-字符集名称；" class="headerlink" title="2>修改表的字符集： alter table 表名 character set 字符集名称；"></a>2&gt;修改表的字符集： alter table 表名 character set 字符集名称；</h6><h6 id="3-gt-添加一列：alter-table-表名-change-表名-新列别-新数据类型；-alter-table-表名-modify-列名-新数据类型；"><a href="#3-gt-添加一列：alter-table-表名-change-表名-新列别-新数据类型；-alter-table-表名-modify-列名-新数据类型；" class="headerlink" title="3>添加一列：alter table 表名 change 表名 新列别 新数据类型；     alter table 表名 modify 列名 新数据类型；"></a>3&gt;添加一列：alter table 表名 change 表名 新列别 新数据类型；     alter table 表名 modify 列名 新数据类型；</h6><h6 id="4-gt-删除列：alter-table-表名-drop-列名；"><a href="#4-gt-删除列：alter-table-表名-drop-列名；" class="headerlink" title="4>删除列：alter table 表名 drop 列名；"></a>4&gt;删除列：alter table 表名 drop 列名；</h6><h5 id="4-D-delete-删除"><a href="#4-D-delete-删除" class="headerlink" title="4.D(delete):删除"></a>4.D(delete):删除</h5><p>   drop table 表名；<br>   drop table if exists 表名；</p><p>​    </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回答</title>
      <link href="/2020/09/01/%E5%9B%9E%E7%AD%94/"/>
      <url>/2020/09/01/%E5%9B%9E%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h1 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h1><ul><li><p>作者：北岛</p><p>  <strong>卑鄙是卑鄙者的通行证</strong> </p><p>  <strong>高尚是高尚者的墓志铭。</strong></p><p>  看吧，在那镀金的天空中，</p><p>  飘满了死者弯曲的倒影。</p><p>  冰川纪过去了，</p><p>  为什么到处都是冰凌？</p><p>  好望角发现了，</p><p>  为什么死海里千帆相竞？</p><p>  我来到这个世界上，</p><p>  只带着纸、绳索和身影，</p><p>  为了在审判之前，</p><p>  宣读那些被判决了的声音：</p><p>  告诉你吧，世界，</p><p>  我——不——相——信！</p><p>  <strong>纵使你脚下有一千名挑战者，</strong></p><p>  <strong>那就把我算做第一千零一名。</strong></p><p>  我不相信天是蓝的，</p><p>  我不相信雷的回声；</p><p>  <strong>我不相信梦是假的，</strong></p><p>  <strong>我不相信死无报应。</strong></p><p>  如果海洋注定要决堤，</p><p>  就让所有的苦水都注入我心中；</p><p>  如果陆地注定要上升，</p><p>  就让人类重新选择生存的峰顶。</p><p>  新的转机和闪闪的星斗，</p><p>  正在缀满没有遮拦的天空，</p><p>  <strong>那是五千年的象形文字，</strong></p><p>  <strong>那是未来人们凝视的眼睛。</strong></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 好文 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
